#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <allegro.h>
#include <string.h>

/// STRUCTURE DES JOUEURS ///
typedef struct joueur  //Cette structure gerera les donnees de joueurs tout au long de la partie
{
        char pseudo[50];
        int classe;
        BITMAP*perso;
        int PA;
        int PM;
        int PU;
        int PV;  // point de vie
        int x;  //c'est une matrice d'entier normalement mais j'arrive pas a initialiser mdrrr on laisse comme ca pour l'instant
        int y;
        int action;
        int lastx; //avec des x et y
        int lasty;
        char CAC[100];
        char Sort1[100];
        char Sort2[100];
        char Passif[100];
        char Ulti[100];
        int brulurempoisonnement;
        int heal;
        int bouclier;
        int repassezplustardsvp;
        int imprimante;
        int mort;
    } t_joueur;

///  INITIALISATION ALLEGRO ///
void initialisationAllegro(){
    allegro_init();
    set_color_depth(desktop_color_depth());
    if((set_gfx_mode(GFX_AUTODETECT_WINDOWED,800,600,0,0))!=0){
        allegro_message("Pb de mode graphique") ;
        allegro_exit();
        exit(EXIT_FAILURE);
    }
    install_keyboard();
    install_mouse();
}

/// AFFICHAGE DES ECRANS ///
//------------------------------------------------------------------//
void AffichageEcran1(int* nb_joueur)
{
    BITMAP* accueil;
    accueil = load_bitmap("menu1BMP.bmp",NULL);

    BITMAP* buffer;
    buffer = create_bitmap(SCREEN_W, SCREEN_H);

    int next=0; //va nous permettre de sortir de la boucle d'affichage lorsqu'un choix est fait

    while(next!=1){

        blit(accueil, buffer, 0, 0, 0, 0,SCREEN_W, SCREEN_H);
        show_mouse(buffer);
        blit(buffer, screen, 0, 0, 0, 0,SCREEN_W, SCREEN_H);
        clear_bitmap(buffer);

        if((mouse_b&1)&&(mouse_x>=174)&&(mouse_x<=290)&&(mouse_y>=286)&&(mouse_y<=387))
            {
                *nb_joueur=2;
                next=1;
                //allegro_message("joueur2");
            }

        if((mouse_b&1)&&(mouse_x>=320)&&(mouse_x<=431)&&(mouse_y>=286)&&(mouse_y<=387))
            {
                *nb_joueur=3;
                next=1;
                //allegro_message("joueur3");
            }

        if((mouse_b&1)&&(mouse_x>=463)&&(mouse_x<=575)&&(mouse_y>=286)&&(mouse_y<=387))
            {
                *nb_joueur=4;
                next=1;
                //allegro_message("joueur4");
            }
    }
}

void AffichageEcran2()
{
    BITMAP* accueil2;
    accueil2 = load_bitmap("menu2BMP.bmp",NULL);

    BITMAP* buffer2;
    buffer2 = create_bitmap(SCREEN_W, SCREEN_H);

    blit(accueil2, buffer2, 0, 0, 0, 0,SCREEN_W, SCREEN_H);
    show_mouse(buffer2);
    blit(buffer2, screen, 0, 0, 0, 0,SCREEN_W, SCREEN_H);
    clear_bitmap(buffer2);
    getchar();
}
//-----------------------------------------------------------//

/// FONCTIONS REMPLISSAGE DES INFOS JOUEURS ///
//-----------------------------------------------------------//
t_joueur* my_init(t_joueur* tab, int* nb_joueur) //On fait une fonction au type de la structure afin de pouvoir renvoyer ses modifications
{
    AffichageEcran1(nb_joueur);

    tab = (t_joueur*)malloc(*nb_joueur * sizeof(t_joueur));  //Allocation dynamique de Tab et test pour blinder l'alloc

    if (tab == NULL)
        allegro_message("ERROR ALLOC");

    for (int i = 0 ; i< *nb_joueur ; i++)
    {
            tab[i].x = 1+rand()%8 ;
            tab[i].y = 1+rand()%8;
            tab[i].lastx =0 ;
            tab[i].lasty = 0;
            tab[i].PU=0;
            tab[i].PA=5;
            tab[i].PM=1;
            tab[i].repassezplustardsvp = 0;
            tab[i].action=0;
            tab[i].bouclier=0;
            tab[i].brulurempoisonnement=0;
            tab[i].heal=0;
            tab[i].imprimante=0;
            tab[i].mort=0;
    }
    return (tab);
}

void dataFill (t_joueur* num_joueur, int* nb_joueur)
{
    int compteur =0; // Initialisation d'un compteur qui va nous permettre de blinder la saisie
    AffichageEcran2();

    for (int i = 0; i<*nb_joueur; i++)  // Boucle for qui va saisir pour chaque joueur le pseudo
    {                                                           // On remplit pour un joueur et le compteur passe à 1.
        printf("\nVeuillez saisir le nom de travailleur :\n");
        scanf("%s", num_joueur[i].pseudo);
        printf("\nVeuillez choisir votre classe.\n");
        do
        {
            fflush(stdin);
            printf("\nTAPEZ - [1] pour la classe Hopital");
            printf("\n        [2] pour la classe La Poste");
            printf("\n        [3] pour la classe Brigade Anti-Criminalite");
            printf("\n        [4] pour la classe Eboueurs");
            printf("\n        [5] pour la classe Mairie");
            printf("\n        [6] pour la classe RATP\n");
            scanf("%d", &(num_joueur[i].classe));
            if(compteur>0) // Si ce compteur passe à 1 ou +, on analyse les données des autres joueurs pour vérifier si le pion n'est pas déjà pris
            {
                for(int J=0 ; J<compteur ; J++)
                {
                    if(num_joueur[J].classe==num_joueur[i].classe)
                    {
                        printf("\n C'est la meme classe que le joueur %d", J+1);
                         printf("\nLa classe saisie est: %d",(num_joueur[i].classe));
                         num_joueur[i].classe=0;
                         printf("\nREFAITES UN CHOIX ");
                    }
                }
            }
        }
        while ((num_joueur[i].classe <1) || (num_joueur[i].classe >6)); //blindage de la saisie
        compteur++;
      }
     allegro_message("Nom et classe des travailleurs valides!");
    //destroy_bitmap(buffer2);

    for (int i = 0; i<*nb_joueur; i++)
    {
        switch (num_joueur[i].classe)
        {
        case(1):
            num_joueur[i].PV =1000 ;
            strcpy(num_joueur[i].CAC,"Scalpel rouille");
            strcpy(num_joueur[i].Sort1,"Seringue de H1N1");
            strcpy(num_joueur[i].Sort2,"Lancer de brancard");
            strcpy(num_joueur[i].Passif,"Bisous d'infirmiere");
            strcpy(num_joueur[i].Ulti,"Piqure d'amphetamines");
            num_joueur[i].perso = load_bitmap("medecinbisBMP.bmp",NULL);

            break;

        case(2):
            num_joueur[i].PV = 800;
            strcpy(num_joueur[i].CAC,"Coup de tampon-encre");
            strcpy(num_joueur[i].Sort1,"Tempete de timbre");
            strcpy(num_joueur[i].Sort2,"Colis piege");
            strcpy(num_joueur[i].Passif,"Lettre verte");
            strcpy(num_joueur[i].Ulti,"Piqure d'amphetamines");
            num_joueur[i].perso = load_bitmap("facteurbisBMP.bmp",NULL);
            break;

        case(3):
            num_joueur[i].PV = 900;
            strcpy(num_joueur[i].CAC,"Coup de matraque");
            strcpy(num_joueur[i].Sort1,"LBD");
            strcpy(num_joueur[i].Sort2,"Gazeuse");
            strcpy(num_joueur[i].Passif,"IGPN");
            strcpy(num_joueur[i].Ulti,"Benalla à Contrescape");
            num_joueur[i].perso = load_bitmap("policierbisBMP.bmp",NULL);
            break;

        case(4):
            num_joueur[i].PV = 850;
            strcpy(num_joueur[i].CAC,"Pare-choc avant de camion poubelle");
            strcpy(num_joueur[i].Sort1,"Megot encore chaud");
            strcpy(num_joueur[i].Sort2,"Tesson de Heineken");
            strcpy(num_joueur[i].Passif,"Immunite biologique");
            strcpy(num_joueur[i].Ulti,"Tri selectif");
            num_joueur[i].perso = load_bitmap("eboueurbisBMP.bmp",NULL);
            break;

        case(5):
            num_joueur[i].PV = 800;
            strcpy(num_joueur[i].CAC,"Baffe du maire");
            strcpy(num_joueur[i].Sort1,"Tir d'agrapheuse");
            strcpy(num_joueur[i].Sort2,"Cafe bouillant");
            strcpy(num_joueur[i].Passif,"Creation d'un passport");
            strcpy(num_joueur[i].Ulti,"Imprimante defaillante");
            num_joueur[i].perso = load_bitmap("mairebisBMP.bmp",NULL);
            break;

        case(6):
            num_joueur[i].PV = 800;
            strcpy(num_joueur[i].CAC,"Coup de tourniquet");
            strcpy(num_joueur[i].Sort1,"Terminus Porte de la Chapelle");
            strcpy(num_joueur[i].Sort2,"Accident sur les rails");
            strcpy(num_joueur[i].Passif,"Contravention de classe 4");
            strcpy(num_joueur[i].Ulti,"Envie pressante du cheminot");
            num_joueur[i].perso = load_bitmap("ratpbisBMP.bmp",NULL);
            break;
        }
    }
}
//-------------------------------------------------------------//
void sleep(int n);

void song()
{
    SAMPLE*son;
    install_sound(DIGI_AUTODETECT,MIDI_AUTODETECT,"A");
    son=load_sample("marseillaise.wav");
    play_sample(son,255,0,1000,0);
}

int xPixeltoCoor(int xPixel)
{
    if((xPixel>=201)&&(xPixel<251))
        return 1;
    else if((xPixel>=251)&&(xPixel<301))
        return 2;
    else if((xPixel>=301)&&(xPixel<351))
        return 3;
    else if((xPixel>=351)&&(xPixel<401))
        return 4;
    else if((xPixel>=401)&&(xPixel<451))
        return 5;
    else if((xPixel>=451)&&(xPixel<501))
        return 6;
    else if((xPixel>=501)&&(xPixel<551))
        return 7;
    else if((xPixel>=551)&&(xPixel<601))
        return 8;
    else
    {
        return 0;
        allegro_message("error xPixeltoCoor");
    }

}

int yPixeltoCoor(int yPixel)
{
    if((yPixel>=101)&&(yPixel<151))
        return 1;
    else if((yPixel>=151)&&(yPixel<201))
        return 2;
    else if((yPixel>=201)&&(yPixel<251))
        return 3;
    else if((yPixel>=251)&&(yPixel<301))
        return 4;
    else if((yPixel>=301)&&(yPixel<351))
        return 5;
    else if((yPixel>=351)&&(yPixel<401))
        return 6;
    else if((yPixel>=401)&&(yPixel<451))
        return 7;
    else if((yPixel>=451)&&(yPixel<501))
        return 8;
    else
    {
        return 0;
        allegro_message("Error yPixeltoCoor");
    }
}

int xCoortoPixel(int xCoor)
{
    if(xCoor==1)
        return 201;
    else if(xCoor==2)
        return 251;
    else if(xCoor==3)
        return 301;
    else if(xCoor==4)
        return 351;
    else if(xCoor==5)
        return 401;
    else if(xCoor==6)
        return 451;
    else if(xCoor==7)
        return 501;
    else if(xCoor==8)
        return 551;
    else
    {
        return 0;
        allegro_message("Error xCoortoPixel");
    }
}

int yCoortoPixel(int yCoor)
{
    if(yCoor==1)
        return 101;
    else if(yCoor==2)
        return 151;
    else if(yCoor==3)
        return 201;
    else if(yCoor==4)
        return 251;
    else if(yCoor==5)
        return 301;
    else if(yCoor==6)
        return 351;
    else if(yCoor==7)
        return 401;
    else if(yCoor==8)
        return 451;
    else
    {
        return 0;
        allegro_message("Error yCoortoPixel");
    }
}

void GrisageCaseRouge(t_joueur* tab, int i, BITMAP* arena, int id)
{
    BITMAP* hachurerouge;
    hachurerouge = load_bitmap("casebarrerougeBMP.bmp",NULL);

    switch(id)
    {
    case(1):
        {
            ///correspond à un CAC (tout autour du joueur)
            if(tab[i].x-1>=1)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y));
            if(tab[i].x+1<=8)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y));
            if(tab[i].y-1>=1)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-1));
            if(tab[i].y+1<=8)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+1));
            if((tab[i].x-1>=1) && (tab[i].y-1>=1))
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y-1));
            if((tab[i].x-1>=1) && (tab[i].y+1<=8))
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y+1));
            if((tab[i].x+1<=8) && (tab[i].y-1>=1))
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y-1));
            if((tab[i].x+1<=8) && (tab[i].y-1<=8))
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y+1));
            break;
        }
    case(2):
        {
            ///correspond a un sort 1
            if(tab[i].x-2>=1)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y));
            if(tab[i].x+2<=8)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y));
            if(tab[i].y-2>=1)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-2));
            if(tab[i].y+2<=8)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+2));
            if(tab[i].x-1>=1)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y));
            if(tab[i].x+1<=8)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y));
            if(tab[i].y-1>=1)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-1));
            if(tab[i].y+1<=8)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+1));
            break;

        }
    case(3):
        {
            ///correspond à un sort 2
            if(tab[i].x-2>=1)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y));
            if(tab[i].x+2<=8)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y));
            if(tab[i].y-2>=1)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-2));
            if(tab[i].y+2<=8)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+2));
            if((tab[i].x+1<=8) && (tab[i].y-2>=1))
                draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y-2));
            if((tab[i].x+2<=8) && (tab[i].y-1>=1))
                draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y-1));
            if((tab[i].x+2<=8) && (tab[i].y+1<=8))
                draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y+1));
            if((tab[i].x+1<=8) && (tab[i].y+2<=8))
                draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y+2));
            if((tab[i].x-1>=1) && (tab[i].y+2<=8))
                draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y+2));
            if((tab[i].x-2>=1) && (tab[i].y+1<=8))
                draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y+1));
            if((tab[i].x-2>=1) && (tab[i].y-1>=1))
                draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y-1));
            if((tab[i].x-1>=1) && (tab[i].y-2>=1))
                draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y-2));
            if((tab[i].x+2<=8) && (tab[i].y-2>=1))
                draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y-2));
            if((tab[i].x+2<=8) && (tab[i].y+2<=8))
                draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y+2));
            if((tab[i].x-2>=1) && (tab[i].y+2<=8))
                draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y+2));
            if((tab[i].x-2>=1) && (tab[i].y-2>=1))
                draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y-2));
            break;
        }
    }
}
void GrisageCaseVert(t_joueur* tab, int  i, BITMAP* arena)
{
    BITMAP* hachurevert;
    hachurevert = load_bitmap("casebarrevertBMP.bmp",NULL);

    switch(tab[i].PM)
    {
    case(1):
        {
            ///affichage case autour du joueur
            if(tab[i].x-1>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y));
            if(tab[i].x+1<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y));
            if(tab[i].y-1>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-1));
            if(tab[i].y+1<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+1));
            break;
        }
    case(2):
        {
            ///affichage case en croix 1 case
            if(tab[i].x-1>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y));
            if(tab[i].x+1<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y));
            if(tab[i].y-1>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-1));
            if(tab[i].y+1<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+1));

            ///affichage case en diagonale
            if((tab[i].x-1>=1) && (tab[i].y-1>=1))
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y-1));
            if((tab[i].x-1>=1) && (tab[i].y+1<=8))
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y+1));
            if((tab[i].x+1<=8) && (tab[i].y-1>=1))
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y-1));
            if((tab[i].x+1<=8) && (tab[i].y-1<=8))
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y+1));

            ///affichage case en croix 2 case
            if(tab[i].x-2>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y));
            if(tab[i].x+2<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y));
            if(tab[i].y-2>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-2));
            if(tab[i].y+2<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+2));
            break;
        }
    case(3):
        {
            ///affichage case en croix 1 case
            if(tab[i].x-1>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y));
            if(tab[i].x+1<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y));
            if(tab[i].y-1>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-1));
            if(tab[i].y+1<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+1));

            ///affichage case en diagonale
            if((tab[i].x-1>=1) && (tab[i].y-1>=1))
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y-1));
            if((tab[i].x-1>=1) && (tab[i].y+1<=8))
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y+1));
            if((tab[i].x+1<=8) && (tab[i].y-1>=1))
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y-1));
            if((tab[i].x+1<=8) && (tab[i].y-1<=8))
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y+1));

            ///affichage case en croix 2 case
            if(tab[i].x-2>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y));
            if(tab[i].x+2<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y));
            if(tab[i].y-2>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-2));
            if(tab[i].y+2<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+2));

            ///affichage case en croix 3 case
            if(tab[i].x-3>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-3),yCoortoPixel(tab[i].y));
            if(tab[i].x+3<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+3),yCoortoPixel(tab[i].y));
            if(tab[i].y-3>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-3));
            if(tab[i].y+3<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+3));

            ///affichage case en diagonale relou
            if((tab[i].x+1<=8) && (tab[i].y-2>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y-2));
            if((tab[i].x+2<=8) && (tab[i].y-1>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y-1));
            if((tab[i].x+2<=8) && (tab[i].y+1<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y+1));
            if((tab[i].x+1<=8) && (tab[i].y+2<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y+2));
            if((tab[i].x-1>=1) && (tab[i].y+2<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y+2));
            if((tab[i].x-2>=1) && (tab[i].y+1<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y+1));
            if((tab[i].x-2>=1) && (tab[i].y-1>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y-1));
            if((tab[i].x-1>=1) && (tab[i].y-2>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y-2));
            break;
        }
    case(4):
        {
            ///affichage case en croix 1 case
            if(tab[i].x-1>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y));
            if(tab[i].x+1<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y));
            if(tab[i].y-1>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-1));
            if(tab[i].y+1<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+1));

            ///affichage case en diagonale
            if((tab[i].x-1>=1) && (tab[i].y-1>=1))
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y-1));
            if((tab[i].x-1>=1) && (tab[i].y+1<=8))
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y+1));
            if((tab[i].x+1<=8) && (tab[i].y-1>=1))
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y-1));
            if((tab[i].x+1<=8) && (tab[i].y-1<=8))
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y+1));

            ///affichage case en croix 2 case
            if(tab[i].x-2>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y));
            if(tab[i].x+2<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y));
            if(tab[i].y-2>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-2));
            if(tab[i].y+2<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+2));

            ///affichage case en croix 3 case
            if(tab[i].x-3>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-3),yCoortoPixel(tab[i].y));
            if(tab[i].x+3<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+3),yCoortoPixel(tab[i].y));
            if(tab[i].y-3>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-3));
            if(tab[i].y+3<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+3));

            ///affichage case en diagonale relou
            if((tab[i].x+1<=8) && (tab[i].y-2>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y-2));
            if((tab[i].x+2<=8) && (tab[i].y-1>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y-1));
            if((tab[i].x+2<=8) && (tab[i].y+1<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y+1));
            if((tab[i].x+1<=8) && (tab[i].y+2<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y+2));
            if((tab[i].x-1>=1) && (tab[i].y+2<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y+2));
            if((tab[i].x-2>=1) && (tab[i].y+1<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y+1));
            if((tab[i].x-2>=1) && (tab[i].y-1>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y-1));
            if((tab[i].x-1>=1) && (tab[i].y-2>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y-2));

            ///affichage case en croix 4 cases
            if(tab[i].x-4>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-4),yCoortoPixel(tab[i].y));
            if(tab[i].x+4<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+4),yCoortoPixel(tab[i].y));
            if(tab[i].y-4>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-4));
            if(tab[i].y+4<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+4));

            ///affichage en diagonale relou 2
            if((tab[i].x+1<=8) && (tab[i].y-3>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y-3));
            if((tab[i].x+2<=8) && (tab[i].y-2>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y-2));
            if((tab[i].x+3<=8) && (tab[i].y-1>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+3),yCoortoPixel(tab[i].y-1));
            if((tab[i].x+1<=8) && (tab[i].y+3<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y+3));
            if((tab[i].x+2<=8) && (tab[i].y+2<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y+2));
            if((tab[i].x+3<=8) && (tab[i].y+1<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+3),yCoortoPixel(tab[i].y+1));
            if((tab[i].x-1>=1) && (tab[i].y+3<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y+3));
            if((tab[i].x-2>=1) && (tab[i].y+2<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y+2));
            if((tab[i].x-3>=1) && (tab[i].y+1<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-3),yCoortoPixel(tab[i].y+1));
            if((tab[i].x-1>=1) && (tab[i].y-3>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y-3));
            if((tab[i].x-2>=1) && (tab[i].y-2>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y-2));
            if((tab[i].x-3>=1) && (tab[i].y-1>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-3),yCoortoPixel(tab[i].y-1));
            break;

        }
    }
}

/// AFFICHAGE DES JOUEURS SUR LE PLATEAU ///
void affichageClasse(t_joueur* tab,BITMAP* arena,int nb_joueur,int i,int j)
{
    do //boucle permettant d'afficher les classes sélectionnées par les joueurs en fonction du nb de joueur
                {
                    switch (tab[j].classe)
                    {
                    case (1):
                       draw_sprite(arena,tab[j].perso,(745),(10));
                       j++; // a chaque fois qu'une sélection est faite on incrémente de 1
                       break;
                    case(2):
                        if(j==0)
                        {
                        draw_sprite(arena,tab[j].perso,(745),(10));
                        }
                        else if(j==1)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(60));
                        }
                        else if(j==2)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(90));
                        }
                        else if(j==3)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(115));
                        }
                        else if(j==4)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(150));
                        }
                        else if (j==5)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(200));
                        }
                        j++;
                        break;
                    case(3):
                        if(j==0)
                        {
                        draw_sprite(arena,tab[j].perso,(745),(10));
                        }
                        else if(j==1)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(60));
                        }
                        else if(j==2)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(90));
                        }
                        else if(j==3)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(115));
                        }
                        else if(j==4)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(150));
                        }
                        else if (j==5)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(200));
                        }

                        j++;
                        break;
                    case(4):
                        if(j==0)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(10));
                        }
                        else if(j==1)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(60));
                        }
                        else if(j==2)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(90));
                        }
                        else if(j==3)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(115));
                        }
                        else if(j==4)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(150));
                        }
                        else if (j==5)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(200));
                        }
                        j++;
                        break;
                    case(5):
                        if(j==0)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(10));
                        }
                        else if(j==1)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(60));
                        }
                        else if(j==2)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(90));
                        }
                        else if(j==3)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(115));
                        }
                        else if(j==4)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(150));
                        }
                        else if (j==5)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(200));
                        }
                        j++;
                        break;
                    case(6):
                        if(j==0)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(10));
                        }
                        else if(j==1)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(60));
                        }
                        else if(j==2)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(90));
                        }
                        else if(j==3)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(115));
                        }
                        else if(j==4)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(150));
                        }
                        else if (j==5)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(200));
                        }
                        j++;
                        break;
                    }
                }while(j<nb_joueur); // on sort d
}
void affichageJoueur2(t_joueur* tab, int nb_joueur,BITMAP*arena,BITMAP* buffer)
{
    for (int i =0 ;i<nb_joueur;i++)
    {
        draw_sprite(arena,tab[i].perso,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y));
    }
}

int calcPm(t_joueur* tab,int choiceX,int choiceY,int i)
{
    int distanceX ;
    int distanceY;
    int totDistance;
    if(choiceX <= tab[i].x && choiceY <= tab[i].y)
    {
        distanceX = (tab[i].x - choiceX);
        distanceY = tab[i].y - choiceY;
    }
    else if (choiceX <= tab[i].x && choiceY >= tab[i].y)
    {
        distanceX = tab[i].x - choiceX;
        distanceY = choiceY - tab[i].y;
    }
    else if (choiceX >= tab[i].x && choiceY <= tab[i].y)
    {
        distanceX = choiceX - tab[i].x;
        distanceY = tab[i].y - choiceY;
    }
    else if (choiceX >= tab[i].x && choiceY >= tab[i].y)
    {
        distanceX = choiceX - tab[i].x;
        distanceY = choiceY- tab[i].y;
    }

    totDistance = distanceX + distanceY;
    return totDistance;


}

void move(t_joueur* tab,int i,BITMAP*arena,BITMAP*buffer, int nb_joueur)
{
    int next1=0;
    int next2=0;
    int xCase=0;
    int yCase=0;
    int newX=0;
    int newY=0;
    int testDistance = 0;


    printf("vous avez choisi le mouvement veuillez cliquer sur une case autour de vous\n");
    printf("%d nb pm\n",tab[i].PM);
    printf("%d coord x",tab[i].x);
    printf("%d coord y",tab[i].y);
    GrisageCaseVert(tab,i,arena);
            do{
                blit(arena, buffer, 0, 0, 0, 0,SCREEN_W, SCREEN_H);
                show_mouse(buffer);
                blit(buffer, screen, 0, 0, 0, 0,SCREEN_W, SCREEN_H);
                clear_bitmap(buffer);
                if((mouse_b&1)&&(mouse_x>=201)&&(mouse_x<601)&&(mouse_y>=101)&&(mouse_y<501))
                {
                    xCase=mouse_x;
                    yCase=mouse_y;
                    newX = xPixeltoCoor(xCase);
                    newY = yPixeltoCoor(yCase);
                    testDistance = calcPm(tab,newX,newY,i);
                    for (int z=0;z<nb_joueur;z++)
                    {
                        if((tab[z].x == newX) &&(tab[z].y == newY))
                        {
                            printf("erreur case occupee");
                            next1 = 0;
                        }

                        else
                        {
                            next1 = 1;
                        }
                    }
                    if ( tab[i].PM - testDistance < 0 )
                        {
                            printf("erreur pas assez de PM \n");
                            next1=0;
                        }

                //allegro_message("Vous avez clique sur une case.");
                }
            }while((next1!=1));
            do
            {
                blit(arena, buffer, 0, 0, 0, 0,SCREEN_W, SCREEN_H);
                show_mouse(buffer);
                blit(buffer, screen, 0, 0, 0, 0,SCREEN_W, SCREEN_H);
                clear_bitmap(buffer);

                printf("distance %d\n",testDistance);
                if((next1 == 1))
                {
                    textprintf_ex(arena, font, 10, 10, makecol(0,0,0), -1, "vous avez suffisament de PM pour y aller");
                    tab[i].lastx = tab[i].x;
                    tab[i].lasty =tab[i].y;
                    tab[i].x = newX;
                    tab[i].y = newY;
                    draw_sprite(arena,tab[i].perso,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y));
                    tab[i].PM = tab[i].PM - testDistance;
                    printf("distance parcourue %d case",testDistance);
                    printf("affectation réussie\n");
                    next2=1;
                }
                else
                {
                    textprintf_ex(arena, font, 10, 10, makecol(0,0,0), -1, "erreur pas assez de PM");
                    move(tab,i,arena,buffer,nb_joueur);
                    //next2=1;
                }
            }while((next2!=1));
next1=0;
next2=0;
printf("fin procedure\n");
}

void affichageFleche(BITMAP*fleche,BITMAP*arena,int nb_joueur , t_joueur* tab,int compteurTour)
{
    switch(compteurTour)
                {
                case(0):
                    draw_sprite(arena,fleche,(700),(15));
                    break;
                case(1):
                    draw_sprite(arena,fleche,(700),(60));
                    break;
                case(2):
                    draw_sprite(arena,fleche,(700),(100));
                    break;
                case(3):
                    draw_sprite(arena,fleche,(700),(130));
                    break;
                case(4):
                    draw_sprite(arena,fleche,(700),(190));
                    break;
                case(5):
                    draw_sprite(arena,fleche,(700),(230));
                    break;
                }
}

void EstTuEnVie(t_joueur* tab, int i)
{
    if(tab[i].PV<=0)
    {
          tab[i].mort=1;
          tab[i].perso=load_bitmap("tetedemort.bmp",NULL);
    }
}

void ClassementDesJoueurs(t_joueur* tab, int nb_joueur)
{
    for(int i=0;i<nb_joueur;i++)
    {
        if(tab[i].mort==0)
            printf("LE GAGNANT EST %s AVEC SON %s !!!\n",tab[i].pseudo,tab[i].CAC);
    }
}

int CombienDeDegats2(t_joueur* tab,int i, int id) //on peut enlever la variable degats et mettre direct des return mais j'ai fait trop vite mdr
{
    int degats=0;

    ///correspond à un corps a corps
    if(id==1)
    {
      switch (tab[i].classe)
      {
    case 1:
        degats=70;
        break;
    case 2:
        degats=70;
        break;
    case 3:
        degats=100;
        break;
    case 4:
        degats=80;
        break;
    case 5:
        degats=70;
        break;
    case 6:
        degats=80;
        break;
      }
    }

    ///correspond à un sort 1
    if(id==2)
    {
        switch (tab[i].classe)
        {
    case 1:
        degats=110;
        break;
    case 2:
        degats=100;
        break;
    case 3:
        degats=100;
        break;
    case 4:
        degats=100;
        break;
    case 5:
        degats=120;
        break;
    case 6:
        degats=110;
        break;
        }
    }

    if(id==3)
    {
        switch(tab[i].classe)
        {
        case 1:
            degats=180;
            break;
        case 2:
            degats=170;
            break;
        case 3:
            degats=170;
            break;
        case 4:
            degats=160;
            break;
        case 5:
            degats=180;
            break;
        case 6:
            degats=200;
            break;
        }
    }
    return degats;
}

int CombienDeDegats(t_joueur* tab,int i, int id) //on peut enlever la variable degats et mettre direct des return mais j'ai fait trop vite mdr
{
    int degats=0;
    int proba=0;
    int fourchette=0;

    ///correspond à un corps a corps
    if(id==1)
    {
      switch (tab[i].classe)
      {
    case 1:
        degats=70;
        break;
    case 2:
        degats=70;
        break;
    case 3:
        degats=100;
        break;
    case 4:
        degats=80;
        break;
    case 5:
        degats=70;
        break;
    case 6:
        degats=80;
        break;
      }
    }

    ///correspond à un sort 1
    if(id==2)
    {
        switch (tab[i].classe)
        {
    case 1:
        degats=110;
        break;
    case 2:
        degats=100;
        break;
    case 3:
        degats=100;
        break;
    case 4:
        degats=100;
        break;
    case 5:
        degats=120;
        break;
    case 6:
        degats=110;
        break;
        }
    }

    if(id==3)
    {
        switch(tab[i].classe)
        {
        case 1:
            degats=180;
            break;
        case 2:
            degats=170;
            break;
        case 3:
            degats=170;
            break;
        case 4:
            degats=160;
            break;
        case 5:
            degats=180;
            break;
        case 6:
            degats=200;
            break;
        }
    }

    ///une chance sur 10 que l'attaque n'inflige aucun degats
    proba=rand()%10;
    if(proba==6)
       degats=0;

    ///fourchette de degats soit 20% moins, soit exact, soit 20% plus
    fourchette=rand()%3;
    if(fourchette==0)
        degats=(int)8*degats/10;
    if(fourchette==1)
        degats=(int)12*degats/10;
    ///si fourchette =2 alors l'attaque reste la même

    ///degats supplementaires de l'ulti hopital
    if((tab[i].classe==1) && tab[i].bouclier>=1)
    {
        tab[i].bouclier=tab[i].bouclier-1;
        degats=degats+70;
    }

    ///si un joueur est affecte par l'ulti de la mairie
    if(tab[i].imprimante>=1)
    {
        degats=(int)degats/2;
        tab[i].imprimante=tab[i].imprimante-1;
    }

    return degats;
}

void Informations(t_joueur* tab, int i, BITMAP* arena)
{
  textprintf_ex(arena, font, 10, 90, makecol(0,0,0), -1, "INFORMATIONS ATTAQUES");
  textprintf_ex(arena, font, 10, 120, makecol(0,0,0), -1, "CAC: -%d PV",CombienDeDegats2(tab,i,1));
  textprintf_ex(arena, font, 10, 140, makecol(0,0,0),-1, "Sort 1: -%d PV",CombienDeDegats2(tab,i,2));
  textprintf_ex(arena, font, 10, 160, makecol(0,0,0),-1, "Sort 2: -%d PV",CombienDeDegats2(tab,i,3));


  ///Info passif
  switch(tab[i].classe)
  {
  case 1:
    textprintf_ex(arena, font, 10, 190, makecol(0,0,0),-1, "Passif: Se soigne de");
    textprintf_ex(arena, font, 10, 200, makecol(0,0,0),-1, "          3x40 PV");
    break;

  case 2:
    textprintf_ex(arena, font, 10, 190, makecol(0,0,0),-1, "Passif: Se soigne de");
    textprintf_ex(arena, font, 10, 200, makecol(0,0,0),-1, "          100 PV");
    break;

  case 3:
    textprintf_ex(arena, font, 60, 170, makecol(0,0,0),-1, "+empoisonnement");
    textprintf_ex(arena, font, 10, 190, makecol(0,0,0),-1, "Passif: Ne recoit pas de");
    textprintf_ex(arena, font, 10, 200, makecol(0,0,0),-1, " degats pendant 2 tours.");
    break;

  case 4:
    textprintf_ex(arena, font, 60, 170, makecol(0,0,0),-1, "+brulure");
    textprintf_ex(arena, font, 10, 190, makecol(0,0,0),-1, "Passif: Cree un obstacle");
    textprintf_ex(arena, font, 10, 200, makecol(0,0,0),-1, "          sur l'arene.");
    break;

  case 5:
    textprintf_ex(arena, font, 60, 170, makecol(0,0,0),-1, "+brulure");
    textprintf_ex(arena, font, 10, 190, makecol(0,0,0),-1, "Passif: Personne ne bouge");
    textprintf_ex(arena, font, 10, 200, makecol(0,0,0),-1, "         pendant 2 tours.");
    break;

  case 6:
    textprintf_ex(arena, font, 60, 170, makecol(0,0,0),-1, "+empoisonnement");
    textprintf_ex(arena, font, 10, 190, makecol(0,0,0),-1, "Passif: Fait perdre 7PA");
    textprintf_ex(arena, font, 10, 200, makecol(0,0,0),-1, "          à un joueur");
    break;
  }


 ///Info ulti
 switch(tab[i].classe)
  {
  case 1:
    textprintf_ex(arena, font, 10, 220, makecol(0,0,0),-1, "Ulti: +70 d'attaque");
    textprintf_ex(arena, font, 10, 230, makecol(0,0,0),-1, "   pendant 3 tours.");
    break;

  case 2:
    textprintf_ex(arena, font, 10, 220, makecol(0,0,0),-1, "Ulti: Fait sauter le ");
    textprintf_ex(arena, font, 10, 230, makecol(0,0,0),-1, "tour des autres joueurs.");
    break;

  case 3:
    textprintf_ex(arena, font, 10, 220, makecol(0,0,0),-1, "Ulti: Tous les joueurs");
    textprintf_ex(arena, font, 10, 230, makecol(0,0,0),-1, "   prennent 150 degats.");
    break;

  case 4:
    textprintf_ex(arena, font, 10, 220, makecol(0,0,0),-1, "Ulti: Vole 2 PA a");
    textprintf_ex(arena, font, 10, 230, makecol(0,0,0),-1, "    chaque joueur");
    break;

  case 5:
    textprintf_ex(arena, font, 10, 220, makecol(0,0,0),-1, "Ulti: Personne ne bouge");
    textprintf_ex(arena, font, 10, 230, makecol(0,0,0),-1, "     pendant 2 tours.");
    break;

  case 6:
    textprintf_ex(arena, font, 10, 220, makecol(0,0,0),-1, "Ulti: Teleportation");
    textprintf_ex(arena, font, 10, 230, makecol(0,0,0),-1, "      n'importe ou");
    break;
  }

}

void HealSoin(t_joueur* tab, int i)
{
    if(tab[i].heal>=1)
    {
        tab[i].PV=tab[i].PV+40;
        tab[i].heal=tab[i].heal-1;
    }
}

void EmpoisonnementBrulure(t_joueur* tab,int i)
{
    if(tab[i].brulurempoisonnement>=1)
    {
        tab[i].PV=tab[i].PV-40;
        tab[i].brulurempoisonnement=tab[i].brulurempoisonnement-1;
    }
}

void CorpsACorps(t_joueur* tab, int i, int nb_joueur,BITMAP* arena)
{
    int xCase, yCase;
    int next=0;

      textprintf_ex(arena, font, 245, 70, makecol(0,0,0), -1, "Vous avez choisi l'attaque %s a 2 PA.",tab[i].CAC);
      textprintf_ex(arena, font, 260, 85, makecol(0,0,0),-1,"Veuillez choisir une case.");
      GrisageCaseRouge(tab,i,arena,1);

      ///Si la souris clique sur l'arene
      if((mouse_b&1)&&(mouse_x>=201)&&(mouse_x<601)&&(mouse_y>=101)&&(mouse_y<501))
      {
         xCase=mouse_x;
         yCase=mouse_y;
         next=1;
         //allegro_message("Vous avez clique sur une case.");
      }

      ///ATTAQUE
      if(next==1)
      {
        for(int k=0;k<nb_joueur;k++)
        {
          ///si un joueur est dans la case visé et que l'attaquant a assez de PA
            if((tab[k].x)==(xPixeltoCoor(xCase)) && (tab[k].y)==(yPixeltoCoor(yCase)) && (tab[i].PA>=2))
            {
              tab[k].PV=tab[k].PV-CombienDeDegats(tab,i,2);
              tab[i].PA=tab[i].PA-2;
              tab[i].PU=tab[i].PU+2;
              tab[i].action=0;
              printf("attaque reussite.\n");
              //allegro_message("Attaque réussie");
            }

            ///si le joueur attaque a un bouclier
            if(tab[k].bouclier>=1)
            {
                tab[k].PV=tab[k].PV+CombienDeDegats(tab,i,2);
                tab[k].bouclier=tab[k].bouclier-1;
            }
        }
      }

      if(tab[i].action==0)
       sleep(1);
}

void PremierSort(t_joueur* tab, int i, int nb_joueur, BITMAP* arena)
{
    int xCase, yCase;
    int next=0;

      textout_ex(arena,font,"Vous avez choisi le premier sort a 3PA.", 245, 70,makecol(0,0,0),-1);
      textout_ex(arena,font,"Veuillez appuyer sur la case de votre attaque.",260,85,makecol(0,0,0),-1);
      GrisageCaseRouge(tab,i,arena,2);
      //clear_bitmap(buffer);

      ///Si la souris clique sur l'arene
      if((mouse_b&1)&&(mouse_x>=201)&&(mouse_x<601)&&(mouse_y>=101)&&(mouse_y<501))
      {
         xCase=mouse_x;
         yCase=mouse_y;
         next=1;
         //allegro_message("Vous avez cliquée sur une case.");
      }

      //ATTAQUE
      if(next==1)
      {
         for(int k=0;k<nb_joueur;k++)
         {
              ///si un joueur est dans la case visé et que l'attaquant a assez de PA
              if((tab[k].x)==(xPixeltoCoor(xCase)) && (tab[k].y)==(yPixeltoCoor(yCase))&&(tab[i].PA>=3))
              {
              tab[k].PV=tab[k].PV-CombienDeDegats(tab,i,2); ///on doit implementer les probabilites des degats
              tab[i].PA=tab[i].PA-3;
              tab[i].PU=tab[i].PU+3;
              tab[i].action=0;
              //allegro_message("Attaque réussie.");
              }
              ///si le joueur attaque a un bouclier
              if(tab[k].bouclier>=1)
              {
                tab[k].PV=tab[k].PV+CombienDeDegats(tab,i,2);
                tab[k].bouclier=tab[k].bouclier-1;
              }
         }
      }
     if(tab[i].action==0)
       sleep(1);
}

void DeuxiemeSort(t_joueur* tab, int i, int nb_joueur, BITMAP* arena)
{
    int xCase, yCase;
    int next=0;

      textout_ex(arena,font,"Vous avez choisi le deuxieme sort a 5PA.", 245, 70,makecol(0,0,0),-1);
      textout_ex(arena,font,"Veuillez appuyer sur la case de votre attaque.",260,85,makecol(0,0,0),-1);
      GrisageCaseRouge(tab,i,arena,3);

      ///Si la souris clique sur l'arene
      if((mouse_b&1)&&(mouse_x>=201)&&(mouse_x<601)&&(mouse_y>=101)&&(mouse_y<501))
      {
         xCase=mouse_x;
         yCase=mouse_y;
         next=1;
      }

      //ATTAQUE
      if(next==1)
      {
         for(int k=0;k<nb_joueur;k++)
         {
              ///si un joueur est dans la case visé et que l'attaquant a assez de PA
              if((tab[k].x)==(xPixeltoCoor(xCase)) && (tab[k].y)==(yPixeltoCoor(yCase))&&(tab[i].PA>=3))
              {
              tab[k].PV=tab[k].PV-CombienDeDegats(tab,i,3); ///on doit implementer les probabilites des degats
              tab[i].PA=tab[i].PA-5;
              tab[i].PU=tab[i].PU+5;
              tab[i].action=0;
              //allegro_message("Attaque réussie.");
              }
              ///si le joueur attaque a un bouclier
              if(tab[k].bouclier>=1)
              {
                tab[k].PV=tab[k].PV+CombienDeDegats(tab,i,3);
                tab[k].bouclier=tab[k].bouclier-1;
              }
         }
      }
     if(tab[i].action==0)
       sleep(1);
}

void Passif(t_joueur* tab, int i, int nb_joueur, BITMAP* arena)
{
    int xCase, yCase;
    int next=0;

    textout_ex(arena,font,"Vous avez choisi le passif a 5PA.", 245, 70,makecol(0,0,0),-1);

    if(tab[i].PA>=5)
    {
      switch(tab[i].classe)
      {
      case 1:
        {
            textout_ex(arena,font,"Bisou d'infirmiere: vous soignez vos effets et +40PV/tour sur 3tours.", 260, 85,makecol(0,0,0),-1);
            tab[i].PV=tab[i].PV+40;
            tab[i].brulurempoisonnement=0;
            tab[i].heal=2;
            tab[i].PA=tab[i].PA-5;
            tab[i].action=0;
            break;
        }
      case 2:
        {
            textout_ex(arena,font,"Lettre verte: +100PV.", 260, 85,makecol(0,0,0),-1);
            tab[i].PV=tab[i].PV+100;
            tab[i].PA=tab[i].PA-5;
            tab[i].action=0;
            break;
        }
      case 3:
        {
            textout_ex(arena,font,"IGPN: Vous etes protege de tout degats pour 3 tours.", 260, 85,makecol(0,0,0),-1);
            tab[i].bouclier=3;
            tab[i].PA=tab[i].PA-5;
            tab[i].action=0;
            break;
        }
      case 4:
        {
            textout_ex(arena,font,"Immunite biologique: +40PV, protege de tout degats pour 1 tour et supprime les effets.", 260, 85,makecol(0,0,0),-1);
            tab[i].bouclier=1;
            tab[i].brulurempoisonnement=0;
            tab[i].PV=tab[i].PV+40;
            tab[i].PA=tab[i].PA-5;
            tab[i].action=0;
            break;
        }
      case 5:
        {
            textout_ex(arena,font,"Creation de passports: tous les joueurs descendent à 0PM.", 260, 85,makecol(0,0,0),-1);
            for(int k=0;k<nb_joueur;k++)
            {
                if(k!=i)
                   tab[k].PM=0;
            }
            tab[i].PA=tab[i].PA-5;
            tab[i].action=0;
            break;
        }
      case 6:
        {
            int done=0;
            textout_ex(arena,font,"Contravention de classe 4: le joueur cible perd 7PA.", 260, 85,makecol(0,0,0),-1);
            if((mouse_b&1)&&(mouse_x>=201)&&(mouse_x<601)&&(mouse_y>=101)&&(mouse_y<501))
            {
             xCase=mouse_x;
             yCase=mouse_y;
             next=1;
            }
            if(next==1)
            {
              for(int k=0;k<nb_joueur;k++)
              {
                 ///si un joueur est dans la case visé
                if(((tab[k].x)==(xPixeltoCoor(xCase))) && ((tab[k].y)==(yPixeltoCoor(yCase))))
                {
                  if(tab[k].PA>=7)
                    tab[k].PA=tab[k].PA-7;
                  if(tab[k].PA<7)
                    tab[k].PA=0;
                  done=1;
                }
              }
            }
            if(done==1)
            {
              tab[i].PA=tab[i].PA-5;
              tab[i].action=0;
            }
            break;
        }
      }
    }
     if(tab[i].action==0)
       sleep(1);
}

void Ulti(t_joueur* tab, int i, int nb_joueur,BITMAP* arena)
{
    int xCase, yCase;
    int next=0;

    textout_ex(arena,font,"Vous avez choisi l'ulti a 10PU.", 245, 70,makecol(0,0,0),-1);

    if(tab[i].PU>=10)
    {
      switch(tab[i].classe)
      {
      case 1:
        {
            textout_ex(arena,font,"Piqure d'amphetamines: vous faites +70 degats pour 5 tours.", 260, 85,makecol(0,0,0),-1);
            tab[i].bouclier=5;
            tab[i].PU=tab[i].PU-10;
            tab[i].action=0;
            break;
        }
      case 2:
        {
            textout_ex(arena,font,"Repassez plus tard: tous les autres joueurs sautent 2 tours.", 260, 85,makecol(0,0,0),-1);
            for(int k=0;k<nb_joueur;k++)
            {
                if(k!=i)
                    tab[k].repassezplustardsvp=2;
            }
            tab[i].PU=tab[i].PU-10;
            tab[i].action=0;
            break;
        }
      case 3:
        {
            textout_ex(arena,font,"Benalla: tous les autres joueurs prennent 150 degats a cause de leur manif.", 260, 85,makecol(0,0,0),-1);
            for(int k=0;k<nb_joueur;k++)
            {
                if(k!=i)
                    tab[k].PV=tab[i].PV-150;
            }
            tab[i].PU=tab[i].PU-10;
            tab[i].action=0;
            break;
        }
      case 4:
        {
            textout_ex(arena,font,"Tri selectif: vous volez 2 PA a chaque joueur.", 260, 85,makecol(0,0,0),-1);
            for(int k=0;k<nb_joueur;k++)
            {
                if(k!=i)
                    tab[k].PA=tab[i].PA-2;
            }
            tab[i].PU=tab[i].PU-10;
            tab[i].PA=tab[i].PA+(2*(nb_joueur-1));
            tab[i].action=0;
            break;
        }
      case 5:
        {
            textout_ex(arena,font,"Imprimante defaillante: tous les autres joueurs ont leur degats divise par 2 pendant 2 tours.", 260, 85,makecol(0,0,0),-1);
            for(int k=0;k<nb_joueur;k++)
            {
                if(k!=i)
                   tab[k].imprimante=2;
            }
            tab[i].PU=tab[i].PU-10;
            tab[i].action=0;
            break;
        }
      case 6:
        {
            textout_ex(arena,font,"Envie pressante du cheminot: aller sur la case de votre choix.", 260, 85,makecol(0,0,0),-1);
            if((mouse_b&1)&&(mouse_x>=201)&&(mouse_x<601)&&(mouse_y>=101)&&(mouse_y<501))
            {
             xCase=mouse_x;
             yCase=mouse_y;
             next=1;
            }
            if(next==1)
            {
              tab[i].x=xPixeltoCoor(xCase);
              tab[i].y=yPixeltoCoor(yCase);
              tab[i].PU=tab[i].PU-10;
              tab[i].action=0;
            }
            break;
        }
      }
    }
     if(tab[i].action==0)
       sleep(1);
}

/// GESTION DES TOURS ///
void gestionTours(t_joueur* tab, int nb_joueur, int reset)
{
    int turn=0;
    int next=0;
    clock_t t1;
    clock_t t2;
    int duree=0;
    int j =0;
    int compteurTour=0; // va nous permettre de repérer le tour du joueur tout au long de la partie
    int positionClock=0;
    int choix=0;
    int end=0;
    int compteurmort=0;

    printf("test rejouer la partie");

    if(reset==1)
    {
        printf("test2 rejouer la partie");
        for(int fornier=0;fornier<nb_joueur;fornier++)
        {
            tab[fornier].x = 1+rand()%8 ;
            tab[fornier].y = 1+rand()%8;
            tab[fornier].lastx =0 ;
            tab[fornier].lasty = 0;
            tab[fornier].PU=0;
            tab[fornier].PA=5;
            tab[fornier].PM=1;
            tab[fornier].repassezplustardsvp = 0;
            tab[fornier].action=0;
            tab[fornier].bouclier=0;
            tab[fornier].brulurempoisonnement=0;
            tab[fornier].heal=0;
            tab[fornier].imprimante=0;
            tab[fornier].mort=0;

            switch (tab[fornier].classe)
        {
        case(1):
            tab[fornier].PV =1000 ;
            strcpy(tab[fornier].CAC,"Scalpel rouille");
            strcpy(tab[fornier].Sort1,"Seringue de H1N1");
            strcpy(tab[fornier].Sort2,"Lancer de brancard");
            strcpy(tab[fornier].Passif,"Bisous d'infirmiere");
            strcpy(tab[fornier].Ulti,"Piqure d'amphetamines");
            tab[fornier].perso = load_bitmap("medecinbisBMP.bmp",NULL);

            break;

        case(2):
            tab[fornier].PV = 800;
            strcpy(tab[fornier].CAC,"Coup de tampon-encre");
            strcpy(tab[fornier].Sort1,"Tempete de timbre");
            strcpy(tab[fornier].Sort2,"Colis piege");
            strcpy(tab[fornier].Passif,"Lettre verte");
            strcpy(tab[fornier].Ulti,"Piqure d'amphetamines");
            tab[fornier].perso = load_bitmap("facteurbisBMP.bmp",NULL);
            break;

        case(3):
            tab[fornier].PV = 900;
            strcpy(tab[fornier].CAC,"Coup de matraque");
            strcpy(tab[fornier].Sort1,"LBD");
            strcpy(tab[fornier].Sort2,"Gazeuse");
            strcpy(tab[fornier].Passif,"IGPN");
            strcpy(tab[fornier].Ulti,"Benalla à Contrescape");
            tab[fornier].perso = load_bitmap("policierbisBMP.bmp",NULL);
            break;

        case(4):
            tab[fornier].PV = 850;
            strcpy(tab[fornier].CAC,"Pare-choc avant de camion poubelle");
            strcpy(tab[fornier].Sort1,"Megot encore chaud");
            strcpy(tab[fornier].Sort2,"Tesson de Heineken");
            strcpy(tab[fornier].Passif,"Immunite biologique");
            strcpy(tab[fornier].Ulti,"Tri selectif");
            tab[fornier].perso = load_bitmap("eboueurbisBMP.bmp",NULL);
            break;

        case(5):
            tab[fornier].PV = 800;
            strcpy(tab[fornier].CAC,"Baffe du maire");
            strcpy(tab[fornier].Sort1,"Tir d'agrapheuse");
            strcpy(tab[fornier].Sort2,"Cafe bouillant");
            strcpy(tab[fornier].Passif,"Creation d'un passport");
            strcpy(tab[fornier].Ulti,"Imprimante defaillante");
            tab[fornier].perso = load_bitmap("mairebisBMP.bmp",NULL);
            break;

        case(6):
            tab[fornier].PV = 800;
            strcpy(tab[fornier].CAC,"Coup de tourniquet");
            strcpy(tab[fornier].Sort1,"Terminus Porte de la Chapelle");
            strcpy(tab[fornier].Sort2,"Accident sur les rails");
            strcpy(tab[fornier].Passif,"Contravention de classe 4");
            strcpy(tab[fornier].Ulti,"Envie pressante du cheminot");
            tab[fornier].perso = load_bitmap("ratpbisBMP.bmp",NULL);
            break;
        }
        }
    }

// La boucle while permet ici de faire tourner le jeu à l'infini pour ne pas terminer le programme tant que la partie n'est pas terminée
    while ((turn != 9999) && (end!=1))
    {
        for (int i = 0 ; i<nb_joueur ; i++)
        {
            ///reinitialisation des donnees
            next=0;
            positionClock=100;
            t1=clock();
            choix=0;
            compteurmort=0;

            ///déclaration et création des bitmaps d'affichage de plateau et de classe
            BITMAP* buffer4;
            buffer4 = create_bitmap(SCREEN_W, SCREEN_H);BITMAP* arena;
            arena = load_bitmap("arena.bmp",NULL);
            BITMAP* fleche;
            fleche = load_bitmap("doigt modif bmp2.bmp",NULL);

            ///affichage de la classe
            affichageClasse(tab,arena,nb_joueur,i,j);

            ///Effets des joueurs
            EmpoisonnementBrulure(tab,i);
            HealSoin(tab,i);
            EstTuEnVie(tab,i);

            ///s'il ne reste qu'un joueur la partie prend fin
            for(int j=0;j<nb_joueur;j++)
            {
                if(tab[j].mort==1)
                    compteurmort=compteurmort+1;
            }
            if(compteurmort==nb_joueur-1)
                {
                    end=1;
                    next=1;
                }

            while((next!=1))
            {
                ///calcul temps du tour
                t2=clock();
                duree=t2-t1;
                if(duree%1000 == 0)
                    positionClock = positionClock+15;

                ///routine d'affichage
                blit(arena, buffer4, 0, 0, 0, 0,SCREEN_W, SCREEN_H);
                show_mouse(buffer4);
                blit(buffer4, screen, 0, 0, 0, 0,SCREEN_W, SCREEN_H);
                clear_bitmap(buffer4);

                ///affichage du temps
                textprintf_ex(arena, font, 378, 57, makecol(0,0,0), -1, "%s",tab[i].pseudo);
                textprintf_ex(arena, font, 630, 100, makecol(0,0,0), -1, "Temps:");
                textprintf_ex(arena, font, 680, positionClock, makecol(0,0,0), -1, "%d",duree/1000);

                ///affichage des donnes joueurs
                textprintf_ex(arena, font, 656, 358, makecol(0,0,0), -1, "%d",tab[i].PV);
                textprintf_ex(arena, font, 656, 373, makecol(0,0,0), -1, "%d",tab[i].PA);
                textprintf_ex(arena, font, 656, 388, makecol(0,0,0), -1, "%d",tab[i].PM);
                textprintf_ex(arena, font, 656, 403, makecol(0,0,0), -1, "%d",tab[i].PU);

                ///affichage de la fleche / joueur2
                affichageFleche(fleche,arena,nb_joueur,tab,compteurTour);
                affichageJoueur2(tab,nb_joueur,arena,buffer4);

                ///si le joueur est affecte par l'ulti de la poste il passe son tour
                if(tab[i].repassezplustardsvp>=1)
                {
                    tab[i].PA=tab[i].PA-2;
                    tab[i].PM=tab[i].PM-1;
                    tab[i].repassezplustardsvp=tab[i].repassezplustardsvp-1;
                    next=1;
                    if (compteurTour == nb_joueur-1)
                        compteurTour = 0;
                    else
                        compteurTour++;
                }

                ///si le joueur est mort il passe son tour
                if(tab[i].mort==1)
                    {
                        next=1;
                        if (compteurTour == nb_joueur-1)
                            compteurTour = 0;
                        else
                            compteurTour++;
                    }

                ///Corps à corps
                if(((mouse_b&1)&&(mouse_y>=518)&&(mouse_y<=563)&&(mouse_x>=200)&&(mouse_x<=245)) || choix==1)
                {
                    tab[i].action = 1;
                    choix=1;
                    if(tab[i].PA>=2)
                       CorpsACorps(tab,i,nb_joueur,arena);
                    else
                        choix=0;
                    if(tab[i].action==0)
                    {
                        choix=0;
                        next=1;
                        if (compteurTour == nb_joueur-1)
                            compteurTour = 0;
                        else
                            compteurTour++;
                    }
                    if(mouse_b&2)
                        choix=0;
                }

                ///Sort 1
                if(((mouse_b&1)&&(mouse_y>=518)&&(mouse_y<=563)&&(mouse_x>=250)&&(mouse_x<=295)) || choix==2)
                {
                    tab[i].action = 2;
                    choix=2;
                    if(tab[i].PA>=3)
                       PremierSort(tab,i,nb_joueur,arena);
                    else
                        choix=0;

                    if(tab[i].action==0)
                    {
                        choix=0;
                        next=1;
                        if (compteurTour == nb_joueur-1)
                            compteurTour = 0;
                        else
                            compteurTour++;
                    }
                    if(mouse_b&2)
                        choix=0;
                }

                ///Sort 2
                if(((mouse_b&1)&&(mouse_y>=518)&&(mouse_y<=563)&&(mouse_x>=300)&&(mouse_x<=345)) || choix==3)
                {
                    tab[i].action=3;
                    choix=3;
                    if(tab[i].PA>=5)
                       DeuxiemeSort(tab,i,nb_joueur,arena);
                    else
                        choix=0;

                    if(tab[i].action==0)
                    {
                        choix=0;
                        next=1;
                        if (compteurTour == nb_joueur-1)
                            compteurTour = 0;
                        else
                            compteurTour++;
                    }
                    if(mouse_b&2)
                        choix=0;
                }

                ///Passif
                if(((mouse_b&1)&&(mouse_y>=518)&&(mouse_y<=563)&&(mouse_x>=351)&&(mouse_x<=396)) || choix==4)
                {
                    tab[i].action=4;
                    choix=4;
                    Passif(tab,i,nb_joueur,arena);

                    if(tab[i].action==0)
                    {
                        choix=0;
                        next=1;
                        if (compteurTour == nb_joueur-1)
                            compteurTour = 0;
                        else
                            compteurTour++;
                    }
                    if(mouse_b&2)
                        choix=0;
                }

                ///Mouvement
                if((mouse_b&1)&&(mouse_y>=518)&&(mouse_y<=563)&&(mouse_x>=402)&&(mouse_x<=447))
                {
                    tab[i].action=5;
                    choix=5;
                    if (compteurTour == nb_joueur-1)
                        compteurTour = 0;
                    else
                        compteurTour++;

                    next=1;
                }

                ///Ulti
                if(((mouse_b&1)&&(mouse_y>=518)&&(mouse_y<=563)&&(mouse_x>=453)&&(mouse_x<=498)) || choix==6)
                {
                    tab[i].action=6;
                    choix=6;
                    if(tab[i].PU>=10)
                        Ulti(tab,i,nb_joueur,arena);
                    else
                        choix=0;

                    if(tab[i].action==0)
                    {
                        choix=0;
                        next=1;
                        if (compteurTour == nb_joueur-1)
                            compteurTour = 0;
                        else
                            compteurTour++;
                    }
                    if(mouse_b&2)
                        choix=0;
                }

                ///Info/help
                if((mouse_b&1)&&(mouse_y>=518)&&(mouse_y<=563)&&(mouse_x>=504)&&(mouse_x<=549))
                {
                    tab[i].action=7;
                    choix=7;
                    Informations(tab,i,arena);
                }

                ///Joueur suivant
                if((mouse_b&1)&&(mouse_y>=518)&&(mouse_y<=563)&&(mouse_x>=555)&&(mouse_x<=600))
                {
                    tab[i].action=8;
                    choix=8;
                    next=1;
                    if (compteurTour == nb_joueur-1)
                        compteurTour = 0;
                    else
                    compteurTour++;
                }

                ///Duree de jeu
                if(duree>15000)
                {
                    next=1;
                    if (compteurTour == nb_joueur-1)
                        compteurTour = 0;
                    else
                    compteurTour++;
                }
            }
            if (tab[i].action == 5)
                {
                    move(tab,i,arena,buffer4,nb_joueur);
                    tab[i].action=0;
                }
            ///si le joueur n'est pas mort on lui donne des PA/PM
            if((tab[i].PM<4) && (tab[i].mort!=1))
               tab[i].PM=tab[i].PM+1;
            if((tab[i].PA<20) && (tab[i].mort!=1))
               tab[i].PA=tab[i].PA+2;
            turn++;
            sleep(1);
        }
    }
}

/// LANCEMENT DE LA PARTIE ///
void LancementPartie(t_joueur* tab,int nb_joueur)
{
    tab = my_init(tab, &nb_joueur);
    dataFill(tab, &nb_joueur);
    song();
    gestionTours(tab, nb_joueur,0);
}

void GameOver(t_joueur* tab, int nb_joueur)
{
   int next=0;
   int choix=0;

   BITMAP* EcranDeFin;
   EcranDeFin=load_bitmap("GameOver.bmp",NULL);

   BITMAP* buffer;
   buffer = create_bitmap(SCREEN_W, SCREEN_H);


    while(next!=1){

        blit(EcranDeFin, buffer, 0, 0, 0, 0,SCREEN_W, SCREEN_H);
        show_mouse(buffer);
        blit(buffer, screen, 0, 0, 0, 0,SCREEN_W, SCREEN_H);
        clear_bitmap(buffer);

        if((mouse_b&1)&&(mouse_x>=216)&&(mouse_x<=586)&&(mouse_y>=243)&&(mouse_y<=311))
            {
                next=1;
                choix=1;
            }

        if((mouse_b&1)&&(mouse_x>=216)&&(mouse_x<=586)&&(mouse_y>=330)&&(mouse_y<=402))
            {
                next=1;
                choix=2;
            }

        if((mouse_b&1)&&(mouse_x>=216)&&(mouse_x<=586)&&(mouse_y>=420)&&(mouse_y<=486))
            {
                next=1;
                choix=3;
            }

        if((mouse_b&1)&&(mouse_x>=216)&&(mouse_x<=586)&&(mouse_y>=507)&&(mouse_y<=576))
            {
                next=1;
                choix=4;
            }
    }

    switch(choix)
    {
    case 1:
        ClassementDesJoueurs(tab,nb_joueur);
        break;

    case 2:
        gestionTours(tab,nb_joueur,1);
        break;

    case 3:
        {
        system("cls");
        LancementPartie(tab,nb_joueur);
        break;
        }

    case 4:
        allegro_exit();
        break;
    }
}

int main()
{
    int nb_joueur = 0;
    t_joueur* tab = NULL;
    srand(time(NULL));
    initialisationAllegro();
    LancementPartie(tab,nb_joueur);
    GameOver(tab,nb_joueur);
    free(tab);
    return 0;
}END_OF_MAIN();
