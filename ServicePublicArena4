#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <time.h>
#include <allegro.h>
#include <string.h>


/// STRUCTURE DES JOUEURS ///

typedef struct joueur  //Cette structure gerera les donnees de joueurs tout au long de la partie
{
        char pseudo[50];
        int classe;
        BITMAP*perso;
        int PA;
        int PM;
        int PU;
        int PV;  // point de vie
        int x;  //c'est une matrice d'entier normalement mais j'arrive pas a initialiser mdrrr on laisse comme ca pour l'instant
        int y;
        int action;
        int lastx; //avec des x et y
        int lasty;
        char CAC[100];
        char Sort1[100];
        char Sort2[100];
        char Passif[100];
        char Ulti[100];
        bool sortie;
    } t_joueur;


void sleep(int n);


void song()
{
    SAMPLE*son;

    install_sound(DIGI_AUTODETECT,MIDI_AUTODETECT,"A");

    son=load_sample("marseillaise.wav");

    play_sample(son,255,0,1000,0);

}

///  INITIALISATION ALLEGRO ///

void initialisationAllegro(){
    allegro_init();
    set_color_depth(desktop_color_depth());
    if((set_gfx_mode(GFX_AUTODETECT_WINDOWED,800,600,0,0))!=0){
        allegro_message("Pb de mode graphique") ;
        allegro_exit();
        exit(EXIT_FAILURE);
    }
    install_keyboard();
    install_mouse();
}

/// AFFICHAGE DES ECRANS ///
//------------------------------------------------------------------//

void AffichageEcran1(int* nb_joueur)
{
    BITMAP* accueil;
    accueil = load_bitmap("menu1BMP.bmp",NULL);

    BITMAP* buffer;
    buffer = create_bitmap(SCREEN_W, SCREEN_H);

    int next=0; //va nous permettre de sortir de la boucle d'affichage lorsqu'un choix est fait

    while(next!=1){

        blit(accueil, buffer, 0, 0, 0, 0,SCREEN_W, SCREEN_H);
        show_mouse(buffer);
        blit(buffer, screen, 0, 0, 0, 0,SCREEN_W, SCREEN_H);
        clear_bitmap(buffer);

        if((mouse_b&1)&&(mouse_x>=174)&&(mouse_x<=290)&&(mouse_y>=286)&&(mouse_y<=387))
            {
                *nb_joueur=2;
                next=1;
                //allegro_message("joueur2");
            }

        if((mouse_b&1)&&(mouse_x>=320)&&(mouse_x<=431)&&(mouse_y>=286)&&(mouse_y<=387))
            {
                *nb_joueur=3;
                next=1;
                //allegro_message("joueur3");
            }

        if((mouse_b&1)&&(mouse_x>=463)&&(mouse_x<=575)&&(mouse_y>=286)&&(mouse_y<=387))
            {
                *nb_joueur=4;
                next=1;
                //allegro_message("joueur4");
            }
    }
    allegro_message("Nombre de joueur valide!");
    destroy_bitmap(buffer);
    //clear_bitmap(accueil);
    //destroy_bitmap(accueil);
}

void AffichageEcran2()
{
    BITMAP* accueil2;
    accueil2 = load_bitmap("menu2BMP.bmp",NULL);

    BITMAP* buffer2;
    buffer2 = create_bitmap(SCREEN_W, SCREEN_H);

    blit(accueil2, buffer2, 0, 0, 0, 0,SCREEN_W, SCREEN_H);
    show_mouse(buffer2);
    blit(buffer2, screen, 0, 0, 0, 0,SCREEN_W, SCREEN_H);
    clear_bitmap(buffer2);
    getchar();
}


//-----------------------------------------------------------//


/// FONCTIONS REMPLISSAGE DES INFOS JOUEURS ///
//-----------------------------------------------------------//

t_joueur* my_init(t_joueur* tab, int* nb_joueur) //On fait une fonction au type de la structure afin de pouvoir renvoyer ses modifications
{
    AffichageEcran1(nb_joueur);

    tab = (t_joueur*)malloc(*nb_joueur * sizeof(t_joueur));  //Allocation dynamique de Tab et test pour blinder l'alloc

    if (tab == NULL)
        allegro_message("ERROR ALLOC");

    for (int i = 0 ; i< *nb_joueur ; i++)
    {
            tab[i].x = 1+rand()%8 ;
            tab[i].y = 1+rand()%8;
            tab[i].lastx =0 ;
            tab[i].lasty = 0;
            tab[i].PU=0;
            tab[i].PA=5;
            tab[i].PM=1;
            tab[i].sortie = true;
            tab[i].action=0;
    }
    return (tab);
}

void dataFill (t_joueur* num_joueur, int* nb_joueur)
{
    int compteur =0; // Initialisation d'un compteur qui va nous permettre de blinder la saisie
    AffichageEcran2();

    for (int i = 0; i<*nb_joueur; i++)  // Boucle for qui va saisir pour chaque joueur le pseudo
    {                                                           // On remplit pour un joueur et le compteur passe à 1.
        printf("\nVeuillez saisir le nom de travailleur :\n");
        scanf("%s", num_joueur[i].pseudo);
        printf("\nVeuillez choisir votre classe.\n");
        do
        {
            fflush(stdin);
            printf("\nTAPEZ - [1] pour la classe Hopital");
            printf("\n        [2] pour la classe La Poste");
            printf("\n        [3] pour la classe Brigade Anti-Criminalite");
            printf("\n        [4] pour la classe Eboueurs");
            printf("\n        [5] pour la classe Mairie");
            printf("\n        [6] pour la classe RATP\n");
            scanf("%d", &(num_joueur[i].classe));
            if(compteur>0) // Si ce compteur passe à 1 ou +, on analyse les données des autres joueurs pour vérifier si le pion n'est pas déjà pris
            {
                for(int J=0 ; J<compteur ; J++)
                {
                    if(num_joueur[J].classe==num_joueur[i].classe)
                    {
                        printf("\n C'est la meme classe que le joueur %d", J+1);
                         printf("\nLa classe saisie est: %d",(num_joueur[i].classe));
                         num_joueur[i].classe=0;
                         printf("\nREFAITES UN CHOIX ");
                    }
                }
            }
        }
        while ((num_joueur[i].classe <1) || (num_joueur[i].classe >6)); //blindage de la saisie
        compteur++;
      }
    allegro_message("Nom et classe des travailleurs valides!");
    //destroy_bitmap(buffer2);

    for (int i = 0; i<*nb_joueur; i++)
    {
        switch (num_joueur[i].classe)
        {
        case(1):
            num_joueur[i].PV =1000 ;
            strcpy(num_joueur[i].CAC,"Scalpel rouille");
            strcpy(num_joueur[i].Sort1,"Seringue de H1N1");
            strcpy(num_joueur[i].Sort2,"Lancer de brancard");
            strcpy(num_joueur[i].Passif,"Bisous d'infirmiere");
            strcpy(num_joueur[i].Ulti,"Piqure d'amphetamines");
            num_joueur[i].perso = load_bitmap("medecinBMP.bmp",NULL);

            break;

        case(2):
            num_joueur[i].PV = 800;
            strcpy(num_joueur[i].CAC,"Coup de tampon-encre");
            strcpy(num_joueur[i].Sort1,"Tempete de timbre");
            strcpy(num_joueur[i].Sort2,"Colis piege");
            strcpy(num_joueur[i].Passif,"Lettre verte");
            strcpy(num_joueur[i].Ulti,"Piqure d'amphetamines");
            num_joueur[i].perso = load_bitmap("facteurBMP.bmp",NULL);
            break;

        case(3):
            num_joueur[i].PV = 900;
            strcpy(num_joueur[i].CAC,"Coup de matraque");
            strcpy(num_joueur[i].Sort1,"LBD");
            strcpy(num_joueur[i].Sort2,"Gazeuse");
            strcpy(num_joueur[i].Passif,"IGPN");
            strcpy(num_joueur[i].Ulti,"Benalla à Contrescape");
            num_joueur[i].perso = load_bitmap("BACBMP.bmp",NULL);
            break;

        case(4):
            num_joueur[i].PV = 850;
            strcpy(num_joueur[i].CAC,"Pare-choc avant de camion poubelle");
            strcpy(num_joueur[i].Sort1,"Megot encore chaud");
            strcpy(num_joueur[i].Sort2,"Tesson de Heineken");
            strcpy(num_joueur[i].Passif,"Encombrant");
            strcpy(num_joueur[i].Ulti,"Tri selectif");
            num_joueur[i].perso = load_bitmap("eboueur.bmp",NULL);
            break;

        case(5):
            num_joueur[i].PV = 800;
            strcpy(num_joueur[i].CAC,"Baffe du maire");
            strcpy(num_joueur[i].Sort1,"Tir d'agrapheuse");
            strcpy(num_joueur[i].Sort2,"Cafe bouillant");
            strcpy(num_joueur[i].Passif,"Creation d'un passport");
            strcpy(num_joueur[i].Ulti,"Imprimante defaillante");
            num_joueur[i].perso = load_bitmap("AnneBMP.bmp",NULL);
            break;

        case(6):
            num_joueur[i].PV = 800;
            strcpy(num_joueur[i].CAC,"Coup de tourniquet");
            strcpy(num_joueur[i].Sort1,"Terminus Porte de la Chapelle");
            strcpy(num_joueur[i].Sort2,"Accident sur les rails");
            strcpy(num_joueur[i].Passif,"Contravention de classe 4");
            strcpy(num_joueur[i].Ulti,"Envie pressante du cheminot");
            num_joueur[i].perso = load_bitmap("controleurBMP.bmp",NULL);
            break;
        }
    }
}
int xPixeltoCoor(int xPixel) ///à faire avec les coordonnées de toutes les cases
{
    if((xPixel>=201)&&(xPixel<251))
        return 1;
    else if((xPixel>=251)&&(xPixel<301))
        return 2;
    else if((xPixel>=301)&&(xPixel<351))
        return 3;
    else if((xPixel>=351)&&(xPixel<401))
        return 4;
    else if((xPixel>=401)&&(xPixel<451))
        return 5;
    else if((xPixel>=451)&&(xPixel<501))
        return 6;
    else if((xPixel>=501)&&(xPixel<551))
        return 7;
    else if((xPixel>=551)&&(xPixel<601))
        return 8;
    else
    {
        return 0;
        allegro_message("error xPixeltoCoor");
    }

}

int yPixeltoCoor(int yPixel) ///à faire avec les coordonnées de toutes les cases
{
    if((yPixel>=101)&&(yPixel<151))
        return 1;
    else if((yPixel>=151)&&(yPixel<201))
        return 2;
    else if((yPixel>=201)&&(yPixel<251))
        return 3;
    else if((yPixel>=251)&&(yPixel<301))
        return 4;
    else if((yPixel>=301)&&(yPixel<351))
        return 5;
    else if((yPixel>=351)&&(yPixel<401))
        return 6;
    else if((yPixel>=401)&&(yPixel<451))
        return 7;
    else if((yPixel>=451)&&(yPixel<501))
        return 8;
    else
    {
        return 0;
        allegro_message("Error yPixeltoCoor");
    }
}

int xCoortoPixel(int xCoor) ///a faire avec les pixels de toutes les cases
{
    if(xCoor==1)
        return 201;
    else if(xCoor==2)
        return 251;
    else if(xCoor==3)
        return 301;
    else if(xCoor==4)
        return 351;
    else if(xCoor==5)
        return 401;
    else if(xCoor==6)
        return 451;
    else if(xCoor==7)
        return 501;
    else if(xCoor==8)
        return 551;
    else
    {
        return 0;
        allegro_message("Error xCoortoPixel");
    }
}

int yCoortoPixel(int yCoor) ///a faire avec les pixels de toutes les cases
{
    if(yCoor==1)
        return 101;
    else if(yCoor==2)
        return 151;
    else if(yCoor==3)
        return 201;
    else if(yCoor==4)
        return 251;
    else if(yCoor==5)
        return 301;
    else if(yCoor==6)
        return 351;
    else if(yCoor==7)
        return 401;
    else if(yCoor==8)
        return 451;
    else
    {
        return 0;
        allegro_message("Error yCoortoPixel");
    }
}

void GrisageCaseRouge(t_joueur* tab, int i, BITMAP* arena, int id)
{
    BITMAP* hachurerouge;
    hachurerouge = load_bitmap("casebarrerougeBMP.bmp",NULL);

    switch(id)
    {
    case(1):
        {
            ///correspond à un CAC (tout autour du joueur)
            if(tab[i].x-1>=1)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y));
            if(tab[i].x+1<=8)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y));
            if(tab[i].y-1>=1)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-1));
            if(tab[i].y+1<=8)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+1));
            if((tab[i].x-1>=1) && (tab[i].y-1>=1))
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y-1));
            if((tab[i].x-1>=1) && (tab[i].y+1<=8))
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y+1));
            if((tab[i].x+1<=8) && (tab[i].y-1>=1))
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y-1));
            if((tab[i].x+1<=8) && (tab[i].y-1<=8))
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y+1));
            break;
        }
    case(2):
        {
            ///correspond a un sort 1
            if(tab[i].x-2>=1)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y));
            if(tab[i].x+2<=8)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y));
            if(tab[i].y-2>=1)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-2));
            if(tab[i].y+2<=8)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+2));
            if(tab[i].x-1>=1)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y));
            if(tab[i].x+1<=8)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y));
            if(tab[i].y-1>=1)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-1));
            if(tab[i].y+1<=8)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+1));
            break;

        }
    case(3):
        {
            ///correspond à un sort 2
            if(tab[i].x-2>=1)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y));
            if(tab[i].x+2<=8)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y));
            if(tab[i].y-2>=1)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-2));
            if(tab[i].y+2<=8)
               draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+2));
            if((tab[i].x+1<=8) && (tab[i].y-2>=1))
                draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y-2));
            if((tab[i].x+2<=8) && (tab[i].y-1>=1))
                draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y-1));
            if((tab[i].x+2<=8) && (tab[i].y+1<=8))
                draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y+1));
            if((tab[i].x+1<=8) && (tab[i].y+2<=8))
                draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y+2));
            if((tab[i].x-1>=1) && (tab[i].y+2<=8))
                draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y+2));
            if((tab[i].x-2>=1) && (tab[i].y+1<=8))
                draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y+1));
            if((tab[i].x-2>=1) && (tab[i].y-1>=1))
                draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y-1));
            if((tab[i].x-1>=1) && (tab[i].y-2>=1))
                draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y-2));
            if((tab[i].x+2<=8) && (tab[i].y-2>=1))
                draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y-2));
            if((tab[i].x+2<=8) && (tab[i].y+2<=8))
                draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y+2));
            if((tab[i].x-2>=1) && (tab[i].y+2<=8))
                draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y+2));
            if((tab[i].x-2>=1) && (tab[i].y-2>=1))
                draw_sprite(arena,hachurerouge,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y-2));
            break;
        }
    }
}
void GrisageCaseVert(t_joueur* tab, int  i, BITMAP* arena)
{
    BITMAP* hachurevert;
    hachurevert = load_bitmap("casebarrevertBMP.bmp",NULL);

    switch(tab[i].PM)
    {
    case(1):
        {
            ///affichage case autour du joueur
            if(tab[i].x-1>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y));
            if(tab[i].x+1<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y));
            if(tab[i].y-1>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-1));
            if(tab[i].y+1<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+1));
            break;
        }
    case(2):
        {
            ///affichage case en croix 1 case
            if(tab[i].x-1>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y));
            if(tab[i].x+1<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y));
            if(tab[i].y-1>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-1));
            if(tab[i].y+1<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+1));

            ///affichage case en diagonale
            if((tab[i].x-1>=1) && (tab[i].y-1>=1))
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y-1));
            if((tab[i].x-1>=1) && (tab[i].y+1<=8))
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y+1));
            if((tab[i].x+1<=8) && (tab[i].y-1>=1))
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y-1));
            if((tab[i].x+1<=8) && (tab[i].y-1<=8))
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y+1));

            ///affichage case en croix 2 case
            if(tab[i].x-2>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y));
            if(tab[i].x+2<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y));
            if(tab[i].y-2>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-2));
            if(tab[i].y+2<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+2));
            break;
        }
    case(3):
        {
            ///affichage case en croix 1 case
            if(tab[i].x-1>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y));
            if(tab[i].x+1<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y));
            if(tab[i].y-1>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-1));
            if(tab[i].y+1<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+1));

            ///affichage case en diagonale
            if((tab[i].x-1>=1) && (tab[i].y-1>=1))
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y-1));
            if((tab[i].x-1>=1) && (tab[i].y+1<=8))
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y+1));
            if((tab[i].x+1<=8) && (tab[i].y-1>=1))
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y-1));
            if((tab[i].x+1<=8) && (tab[i].y-1<=8))
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y+1));

            ///affichage case en croix 2 case
            if(tab[i].x-2>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y));
            if(tab[i].x+2<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y));
            if(tab[i].y-2>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-2));
            if(tab[i].y+2<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+2));

            ///affichage case en croix 3 case
            if(tab[i].x-3>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-3),yCoortoPixel(tab[i].y));
            if(tab[i].x+3<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+3),yCoortoPixel(tab[i].y));
            if(tab[i].y-3>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-3));
            if(tab[i].y+3<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+3));

            ///affichage case en diagonale relou
            if((tab[i].x+1<=8) && (tab[i].y-2>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y-2));
            if((tab[i].x+2<=8) && (tab[i].y-1>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y-1));
            if((tab[i].x+2<=8) && (tab[i].y+1<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y+1));
            if((tab[i].x+1<=8) && (tab[i].y+2<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y+2));
            if((tab[i].x-1>=1) && (tab[i].y+2<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y+2));
            if((tab[i].x-2>=1) && (tab[i].y+1<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y+1));
            if((tab[i].x-2>=1) && (tab[i].y-1>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y-1));
            if((tab[i].x-1>=1) && (tab[i].y-2>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y-2));
            break;
        }
    case(4):
        {
            ///affichage case en croix 1 case
            if(tab[i].x-1>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y));
            if(tab[i].x+1<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y));
            if(tab[i].y-1>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-1));
            if(tab[i].y+1<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+1));

            ///affichage case en diagonale
            if((tab[i].x-1>=1) && (tab[i].y-1>=1))
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y-1));
            if((tab[i].x-1>=1) && (tab[i].y+1<=8))
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y+1));
            if((tab[i].x+1<=8) && (tab[i].y-1>=1))
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y-1));
            if((tab[i].x+1<=8) && (tab[i].y-1<=8))
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y+1));

            ///affichage case en croix 2 case
            if(tab[i].x-2>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y));
            if(tab[i].x+2<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y));
            if(tab[i].y-2>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-2));
            if(tab[i].y+2<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+2));

            ///affichage case en croix 3 case
            if(tab[i].x-3>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-3),yCoortoPixel(tab[i].y));
            if(tab[i].x+3<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+3),yCoortoPixel(tab[i].y));
            if(tab[i].y-3>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-3));
            if(tab[i].y+3<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+3));

            ///affichage case en diagonale relou
            if((tab[i].x+1<=8) && (tab[i].y-2>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y-2));
            if((tab[i].x+2<=8) && (tab[i].y-1>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y-1));
            if((tab[i].x+2<=8) && (tab[i].y+1<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y+1));
            if((tab[i].x+1<=8) && (tab[i].y+2<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y+2));
            if((tab[i].x-1>=1) && (tab[i].y+2<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y+2));
            if((tab[i].x-2>=1) && (tab[i].y+1<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y+1));
            if((tab[i].x-2>=1) && (tab[i].y-1>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y-1));
            if((tab[i].x-1>=1) && (tab[i].y-2>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y-2));

            ///affichage case en croix 4 cases
            if(tab[i].x-4>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-4),yCoortoPixel(tab[i].y));
            if(tab[i].x+4<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+4),yCoortoPixel(tab[i].y));
            if(tab[i].y-4>=1)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y-4));
            if(tab[i].y+4<=8)
               draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y+4));

            ///affichage en diagonale relou 2
            if((tab[i].x+1<=8) && (tab[i].y-3>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y-3));
            if((tab[i].x+2<=8) && (tab[i].y-2>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y-2));
            if((tab[i].x+3<=8) && (tab[i].y-1>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+3),yCoortoPixel(tab[i].y-1));
            if((tab[i].x+1<=8) && (tab[i].y+3<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+1),yCoortoPixel(tab[i].y+3));
            if((tab[i].x+2<=8) && (tab[i].y+2<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+2),yCoortoPixel(tab[i].y+2));
            if((tab[i].x+3<=8) && (tab[i].y+1<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x+3),yCoortoPixel(tab[i].y+1));
            if((tab[i].x-1>=1) && (tab[i].y+3<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y+3));
            if((tab[i].x-2>=1) && (tab[i].y+2<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y+2));
            if((tab[i].x-3>=1) && (tab[i].y+1<=8))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-3),yCoortoPixel(tab[i].y+1));
            if((tab[i].x-1>=1) && (tab[i].y-3>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-1),yCoortoPixel(tab[i].y-3));
            if((tab[i].x-2>=1) && (tab[i].y-2>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-2),yCoortoPixel(tab[i].y-2));
            if((tab[i].x-3>=1) && (tab[i].y-1>=1))
                draw_sprite(arena,hachurevert,xCoortoPixel(tab[i].x-3),yCoortoPixel(tab[i].y-1));
            break;

        }
    }
}

//------------------------------------------------------//
/// AFFICHAGE DES JOUEURS SUR LE PLATEAU ///
void affichageClasse(t_joueur* tab,BITMAP* arena,int nb_joueur,int i,int j)
{
    do //boucle permettant d'afficher les classes sélectionnées par les joueurs en fonction du nb de joueur
                {
                    switch (tab[j].classe)
                    {
                    case (1):
                       draw_sprite(arena,tab[j].perso,(745),(10));
                       j++; // a chaque fois qu'une sélection est faite on incrémente de 1
                       break;
                    case(2):
                        if(j==0)
                        {
                        draw_sprite(arena,tab[j].perso,(745),(10));
                        }
                        else if(j==1)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(60));
                        }
                        else if(j==2)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(90));
                        }
                        else if(j==3)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(115));
                        }
                        else if(j==4)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(150));
                        }
                        else if (j==5)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(200));
                        }
                        j++;
                        break;
                    case(3):
                        if(j==0)
                        {
                        draw_sprite(arena,tab[j].perso,(745),(10));
                        }
                        else if(j==1)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(60));
                        }
                        else if(j==2)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(90));
                        }
                        else if(j==3)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(115));
                        }
                        else if(j==4)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(150));
                        }
                        else if (j==5)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(200));
                        }

                        j++;
                        break;
                    case(4):
                        if(j==0)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(10));
                        }
                        else if(j==1)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(60));
                        }
                        else if(j==2)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(90));
                        }
                        else if(j==3)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(115));
                        }
                        else if(j==4)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(150));
                        }
                        else if (j==5)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(200));
                        }
                        j++;
                        break;
                    case(5):
                        if(j==0)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(10));
                        }
                        else if(j==1)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(60));
                        }
                        else if(j==2)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(90));
                        }
                        else if(j==3)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(115));
                        }
                        else if(j==4)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(150));
                        }
                        else if (j==5)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(200));
                        }
                        j++;
                        break;
                    case(6):
                        if(j==0)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(10));
                        }
                        else if(j==1)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(60));
                        }
                        else if(j==2)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(90));
                        }
                        else if(j==3)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(115));
                        }
                        else if(j==4)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(150));
                        }
                        else if (j==5)
                        {
                            draw_sprite(arena,tab[j].perso,(745),(200));
                        }
                        j++;
                        break;
                    }
                }while(j<nb_joueur); // on sort d
}
void affichageJoueur2(t_joueur* tab, int nb_joueur,BITMAP*arena,BITMAP* buffer)
{
    for (int i =0 ;i<nb_joueur;i++)
    {
        draw_sprite(arena,tab[i].perso,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y));
    }
}

int calcPm(t_joueur* tab,int choiceX,int choiceY,int i)
{
    int distanceX ;
    int distanceY;
    int totDistance;
    if(choiceX <= tab[i].x && choiceY <= tab[i].y)
    {
        distanceX = (tab[i].x - choiceX);
        distanceY = tab[i].y - choiceY;
    }
    else if (choiceX <= tab[i].x && choiceY >= tab[i].y)
    {
        distanceX = tab[i].x - choiceX;
        distanceY = choiceY - tab[i].y;
    }
    else if (choiceX >= tab[i].x && choiceY <= tab[i].y)
    {
        distanceX = choiceX - tab[i].x;
        distanceY = tab[i].y - choiceY;
    }
    else if (choiceX >= tab[i].x && choiceY >= tab[i].y)
    {
        distanceX = choiceX - tab[i].x;
        distanceY = choiceY- tab[i].y;
    }

    totDistance = distanceX + distanceY;
    return totDistance;


}

void move(t_joueur* tab,int i,BITMAP*arena,BITMAP*buffer, int nb_joueur)
{
    int next1=0;
    int next2=0;
    int xCase=0;
    int yCase=0;
    int newX=0;
    int newY=0;
    int testDistance = 0;


    printf("vous avez choisi le mouvement veuillez cliquer sur une case autour de vous\n");
    printf("%d nb pm\n",tab[i].PM);
    printf("%d coord x",tab[i].x);
    printf("%d coord y",tab[i].y);
    GrisageCaseVert(tab,i,arena);
            do{
                blit(arena, buffer, 0, 0, 0, 0,SCREEN_W, SCREEN_H);
                show_mouse(buffer);
                blit(buffer, screen, 0, 0, 0, 0,SCREEN_W, SCREEN_H);
                clear_bitmap(buffer);
                if((mouse_b&1)&&(mouse_x>=201)&&(mouse_x<601)&&(mouse_y>=101)&&(mouse_y<501))
                {
                    xCase=mouse_x;
                    yCase=mouse_y;
                    newX = xPixeltoCoor(xCase);
                    newY = yPixeltoCoor(yCase);
                    testDistance = calcPm(tab,newX,newY,i);
                    for (int z=0;z<nb_joueur;z++)
                    {
                        if((tab[z].x == newX) &&(tab[z].y == newY))
                        {
                            printf("erreur case occupee");
                            next1 = 0;
                        }

                        else
                        {
                            next1 = 1;
                        }
                    }
                    if ( tab[i].PM - testDistance < 0 )
                        {
                            printf("erreur pas assez de PM \n");
                            next1=0;
                        }

                //allegro_message("Vous avez clique sur une case.");
                }
            }while((next1!=1));
            do
            {
                blit(arena, buffer, 0, 0, 0, 0,SCREEN_W, SCREEN_H);
                show_mouse(buffer);
                blit(buffer, screen, 0, 0, 0, 0,SCREEN_W, SCREEN_H);
                clear_bitmap(buffer);

                printf("distance %d\n",testDistance);
                if((next1 == 1))
                {
                    textprintf_ex(arena, font, 10, 10, makecol(0,0,0), -1, "vous avez suffisament de PM pour y aller");
                    tab[i].lastx = tab[i].x;
                    tab[i].lasty =tab[i].y;
                    tab[i].x = newX;
                    tab[i].y = newY;
                    draw_sprite(arena,tab[i].perso,xCoortoPixel(tab[i].x),yCoortoPixel(tab[i].y));
                    tab[i].PM = tab[i].PM - testDistance;
                    printf("distance parcourue %d case",testDistance);
                    printf("affectation réussie\n");
                    next2=1;
                }
                else
                {
                    textprintf_ex(arena, font, 10, 10, makecol(0,0,0), -1, "erreur pas assez de PM");
                    move(tab,i,arena,buffer,nb_joueur);
                    //next2=1;
                }
            }while((next2!=1));
next1=0;
next2=0;
printf("fin procedure\n");
}

void affichageFleche(BITMAP*fleche,BITMAP*arena,int nb_joueur , t_joueur* tab,int compteurTour)
{
    switch(compteurTour)
                {
                case(0):
                    draw_sprite(arena,fleche,(700),(15));
                    break;
                case(1):
                    draw_sprite(arena,fleche,(700),(60));
                    break;
                case(2):
                    draw_sprite(arena,fleche,(700),(100));
                    break;
                case(3):
                    draw_sprite(arena,fleche,(700),(130));
                    break;
                case(4):
                    draw_sprite(arena,fleche,(700),(190));
                    break;
                case(5):
                    draw_sprite(arena,fleche,(700),(230));
                    break;
                }
}


void ronpiche(unsigned long int n) {
        /* boucle vide parcourue (n * 100000) fois*/
        int i = 0;
        unsigned long int max = n * 100000;
        do {

                i++;
        }
        while(i <= max);
}


int CombienDeDegats(int classe, int id) //on peut enlever la variable degats et mettre direct des return mais j'ai fait trop vite mdr
{
    int degats=0;
    int proba=0;
    int fourchette=0;
    ///correspond à un corps a corps
    if(id==1)
    {
      switch (classe)
      {
    case 1:
        degats=70;
        break;
    case 2:
        degats=70;
        break;
    case 3:
        degats=100;
        break;
    case 4:
        degats=80;
        break;
    case 5:
        degats=70;
        break;
    case 6:
        degats=80;
        break;
      }
    }

    ///correspond à un sort 1
    if(id==2)
    {
        switch (classe)
        {
    case 1:
        degats=110;
        break;
    case 2:
        degats=100;
        break;
    case 3:
        degats=100;
        break;
    case 4:
        degats=100;
        break;
    case 5:
        degats=120;
        break;
    case 6:
        degats=110;
        break;
        }
    }

    if(id==3)
    {
        switch(classe)
        {
        case 1:
            degats=180;
            break;
        case 2:
            degats=170;
            break;
        case 3:
            degats=170;
            break;
        case 4:
            degats=160;
            break;
        case 5:
            degats=180;
            break;
        case 6:
            degats=200;
            break;
        }
    }

    ///une chance sur 10 que l'attaque n'inflige aucun degats
    proba=rand()%10;
    if(proba==6)
       degats=0;

    ///fourchette de degats soit 20% moins, soit exact, soit 20% plus
    fourchette=rand()%3;
    if(fourchette==0)
        degats=(int)8*degats/10;
    if(fourchette==1)
        degats=(int)12*degats/10;
    ///si fourchette =2 alors l'attaque reste la même

    return degats;
}

void Informations(t_joueur* tab, int i, BITMAP* arena)
{
  textprintf_ex(arena, font, 10, 90, makecol(0,0,0), -1, "INFORMATIONS ATTAQUES");
  textprintf_ex(arena, font, 10, 120, makecol(0,0,0), -1, "CAC: -%d PV",CombienDeDegats(tab[i].classe,0));
  textprintf_ex(arena, font, 10, 140, makecol(0,0,0),-1, "Sort 1: -%d PV",CombienDeDegats(tab[i].classe,1));
  textprintf_ex(arena, font, 10, 160, makecol(0,0,0),-1, "Sort 2: -%d PV",CombienDeDegats(tab[i].classe,2));

  ///Info passif
  switch(tab[i].classe)
  {
  case 1:
    textprintf_ex(arena, font, 10, 180, makecol(0,0,0),-1, "Passif: Se soigne de");
    textprintf_ex(arena, font, 10, 190, makecol(0,0,0),-1, "          3x40 PV");
    break;

  case 2:
    textprintf_ex(arena, font, 10, 180, makecol(0,0,0),-1, "Passif: Se soigne de");
    textprintf_ex(arena, font, 10, 190, makecol(0,0,0),-1, "          100 PV");
    break;

  case 3:
    textprintf_ex(arena, font, 10, 180, makecol(0,0,0),-1, "Passif: Ne recoit pas de");
    textprintf_ex(arena, font, 10, 190, makecol(0,0,0),-1, " degats pendant 2 tours.");
    break;

  case 4:
    textprintf_ex(arena, font, 10, 180, makecol(0,0,0),-1, "Passif: Cree un obstacle");
    textprintf_ex(arena, font, 10, 190, makecol(0,0,0),-1, "          sur l'arene.");
    break;

  case 5:
    textprintf_ex(arena, font, 10, 180, makecol(0,0,0),-1, "Passif: Personne ne bouge");
    textprintf_ex(arena, font, 10, 190, makecol(0,0,0),-1, "         pendant 2 tours.");
    break;

  case 6:
    textprintf_ex(arena, font, 10, 180, makecol(0,0,0),-1, "Passif: Fait perdre 7PA");
    textprintf_ex(arena, font, 10, 190, makecol(0,0,0),-1, "          à un joueur");
    break;
  }


 ///Info ulti
 switch(tab[i].classe)
  {
  case 1:
    textprintf_ex(arena, font, 10, 210, makecol(0,0,0),-1, "Ulti: +70 d'attaque");
    textprintf_ex(arena, font, 10, 220, makecol(0,0,0),-1, "   pendant 3 tours.");
    break;

  case 2:
    textprintf_ex(arena, font, 10, 210, makecol(0,0,0),-1, "Ulti: Fait sauter le ");
    textprintf_ex(arena, font, 10, 220, makecol(0,0,0),-1, "tour des autres joueurs.");
    break;

  case 3:
    textprintf_ex(arena, font, 10, 210, makecol(0,0,0),-1, "Ulti: Tous les joueurs");
    textprintf_ex(arena, font, 10, 220, makecol(0,0,0),-1, "   prennent 150 degats.");
    break;

  case 4:
    textprintf_ex(arena, font, 10, 210, makecol(0,0,0),-1, "Ulti: Vole 2 PA a");
    textprintf_ex(arena, font, 10, 220, makecol(0,0,0),-1, "    chaque joueur");
    break;

  case 5:
    textprintf_ex(arena, font, 10, 210, makecol(0,0,0),-1, "Ulti: Personne ne bouge");
    textprintf_ex(arena, font, 10, 220, makecol(0,0,0),-1, "     pendant 2 tours.");
    break;

  case 6:
    textprintf_ex(arena, font, 10, 210, makecol(0,0,0),-1, "Ulti: Teleportation");
    textprintf_ex(arena, font, 10, 220, makecol(0,0,0),-1, "      n'importe ou");
    break;
  }

}

void CorpsACorps(t_joueur* tab, int i, int nb_joueur,BITMAP* arena) ///A REVOIR MAUVAISE IDEE D'AVOIR UNE BOUCLE PAR ATTAQUE
{
    int xCase, yCase;
    int next=0;

      textprintf_ex(arena, font, 245, 70, makecol(0,0,0), -1, "Vous avez choisi l'attaque %s a 2 PA.",tab[i].CAC);
      textprintf_ex(arena, font, 260, 85, makecol(0,0,0),-1,"Veuillez choisir une case.");
      GrisageCaseRouge(tab,i,arena,1);

      ///Si la souris clique sur l'arene
      if((mouse_b&1)&&(mouse_x>=201)&&(mouse_x<601)&&(mouse_y>=101)&&(mouse_y<501))
      {
         xCase=mouse_x;
         yCase=mouse_y;
         next=1;
         //allegro_message("Vous avez clique sur une case.");
      }

      ///ATTAQUE
      if(next==1)
      {
        for(int k=0;k<nb_joueur;k++)
        {
          ///si un joueur est dans la case visé et que l'attaquant a assez de PA
            if((tab[k].x)==(xPixeltoCoor(xCase)) && (tab[k].y)==(yPixeltoCoor(yCase) )&& (tab[i].PA>=2))
            {
              tab[k].PV=tab[k].PV-CombienDeDegats(tab[i].classe,2);
              tab[i].PA=tab[i].PA-2;
              tab[i].PU=tab[i].PU+2;
              tab[i].action=0;
              printf("attaque reussite.\n");
              //allegro_message("Attaque réussie");
            }
        }
      }

      if(tab[i].action==0)
       sleep(1);

/*
      ///Si la case cliquée est celle du joueur attaquant
      if((next==1)&&(tab[i].x==xPixeltoCoor(xCase))&&(tab[i].y==yPixeltoCoor(yCase)))
      {
             //allegro_message("Vous êtes sur cette case.");
             printf("Vous etes sur cette case.\n");
             next=0;
      }

      ///Si la case cliquée n'est pas autour du joueur attaquant
      if((next==1)&&((tab[i].x - xPixeltoCoor(xCase)>=2) || (tab[i].x - xPixeltoCoor(xCase)<=-2)||(tab[i].y - yPixeltoCoor(yCase)>= 2) || (tab[i].y - yPixeltoCoor(yCase)<= -2) ))
      {
          //allegro_message("C'est pas une case autour de vous.");
          printf("C'est pas une case autour de vous.\n");
          next=0;
      }

      ///ATTAQUE
      if(next==1)
      {
      for(int k=0;k<nb_joueur;k++)
      {
          ///si un joueur est dans la case visé et que l'attaquant a assez de PA
        if((tab[k].x)==(xPixeltoCoor(xCase)) && (tab[k].y)==(yPixeltoCoor(yCase))&&(tab[i].PA>=2))
            {
              tab[k].PV=tab[k].PV-CombienDeDegats(tab[i].classe,0);
              tab[i].PA=tab[i].PA-2;
              tab[i].PU=tab[i].PU+2;
              printf("attaque reussite.\n");
              //allegro_message("Attaque réussie");
            }

        else if((tab[k].x!=xPixeltoCoor(xCase))||(tab[k].y!=yPixeltoCoor(yCase)))
            {
                next=0;
                //allegro_message("Personne sur cette case.");
                printf("else if Personne sur cette case.\n");

            }

        else if (tab[i].PA<2)
            {
                next=0;
                //allegro_message("Pas assez de PA.");
                printf("Pas assez de PA");
            }
      }
      }
      */

}

void PremierSort(t_joueur* tab, int i, int nb_joueur, BITMAP* arena)
{
    int xCase, yCase;
    int next=0;

      textout_ex(arena,font,"Vous avez choisi le premier sort a 3PA.", 245, 70,makecol(0,0,0),-1);
      textout_ex(arena,font,"Veuillez appuyer sur la case de votre attaque.",260,85,makecol(0,0,0),-1);
      GrisageCaseRouge(tab,i,arena,2);
      //clear_bitmap(buffer);

      ///Si la souris clique sur l'arene
      if((mouse_b&1)&&(mouse_x>=201)&&(mouse_x<601)&&(mouse_y>=101)&&(mouse_y<501))
      {
         xCase=mouse_x;
         yCase=mouse_y;
         next=1;
         //allegro_message("Vous avez cliquée sur une case.");
      }

      //ATTAQUE
      if(next==1)
      {
         for(int k=0;k<nb_joueur;k++)
         {
              ///si un joueur est dans la case visé et que l'attaquant a assez de PA
              if((tab[k].x)==(xPixeltoCoor(xCase)) && (tab[k].y)==(yPixeltoCoor(yCase))&&(tab[i].PA>=3))
              {
              tab[k].PV=tab[k].PV-CombienDeDegats(tab[i].classe,2); ///on doit implementer les probabilites des degats
              tab[i].PA=tab[i].PA-3;
              tab[i].PU=tab[i].PU+3;
              tab[i].action=0;
              //allegro_message("Attaque réussie.");
            }
         }
      }
     if(tab[i].action==0)
       sleep(1);

      /*

      ///Si la case cliquée est trop près de l'attaquant
      if (next==1)
      {
      if(((tab[i].x - xPixeltoCoor(xCase)<=1)&&(tab[i].x - xPixeltoCoor(xCase)>=-1)) || ((tab[i].y - yPixeltoCoor(yCase)<=1)&&(tab[i].y - yPixeltoCoor(yCase)>=-1)))
        {
            next=0;
            allegro_message("Case cliquée trop proche de l'envoyeur");
        }
      }

     ///Si la case cliquée est trop loin de l'attaquant
     if(next==1)
     {
         if(((tab[i].x - xPixeltoCoor(xCase)>=3)&&(tab[i].x - xPixeltoCoor(xCase)<=-3)) || ((tab[i].y - yPixeltoCoor(yCase)>=3)&&(tab[i].y - yPixeltoCoor(yCase)<=-3)))
         {
             next=0;
             allegro_message("Case cliquée trop loin de l'envoyeur");
         }
     }

      ///ATTAQUE
      if(next==1)
      {
      for(int k=0;k<nb_joueur;i++)
      {
          ///si un joueur est dans la case visé et que l'attaquant a assez de PA
        if((tab[k].x)==(xPixeltoCoor(xCase)) && (tab[k].y)==(yPixeltoCoor(yCase))&&(tab[i].PA>=2))
            {
              tab[k].PV=tab[k].PV-CombienDeDegats(tab[i].classe,1); ///on doit implementer les probabilites des degats
              tab[i].PA=tab[i].PA-3;
              tab[i].PU=tab[i].PU+3;
              allegro_message("Attaque réussie.");
            }
        else if((tab[k].x!=xPixeltoCoor(xCase))||(tab[k].y!=yPixeltoCoor(yCase)))
            {
                next=0;
                allegro_message("Personne sur cette case.");
            }
        else if (tab[i].PA<3)
            {
                next=0;
                allegro_message("Pas assez de PA.");
            }
      }
      }
      */
}

void DeuxiemeSort(t_joueur* tab, int i, int nb_joueur, BITMAP* arena)
{
    int xCase, yCase;
    int next=0;

      textout_ex(arena,font,"Vous avez choisi le deuxieme sort a 5PA.", 245, 70,makecol(0,0,0),-1);
      textout_ex(arena,font,"Veuillez appuyer sur la case de votre attaque.",260,85,makecol(0,0,0),-1);
      GrisageCaseRouge(tab,i,arena,3);

      ///Si la souris clique sur l'arene
      if((mouse_b&1)&&(mouse_x>=201)&&(mouse_x<601)&&(mouse_y>=101)&&(mouse_y<501))
      {
         xCase=mouse_x;
         yCase=mouse_y;
         next=1;
      }

      //ATTAQUE
      if(next==1)
      {
         for(int k=0;k<nb_joueur;k++)
         {
              ///si un joueur est dans la case visé et que l'attaquant a assez de PA
              if((tab[k].x)==(xPixeltoCoor(xCase)) && (tab[k].y)==(yPixeltoCoor(yCase))&&(tab[i].PA>=3))
              {
              tab[k].PV=tab[k].PV-CombienDeDegats(tab[i].classe,3); ///on doit implementer les probabilites des degats
              tab[i].PA=tab[i].PA-5;
              tab[i].PU=tab[i].PU+5;
              tab[i].action=0;
              //allegro_message("Attaque réussie.");
            }
         }
      }
     if(tab[i].action==0)
       sleep(1);
}

/// GESTION DES TOURS ///

void gestionTours(t_joueur* tab, int nb_joueur)
{
    int turn=0;
    int next=0;
    clock_t t1;
    clock_t t2;
    int duree=0;
    int j =0;
    int compteurTour=0; // va nous permettre de repérer le tour du joueur tout au long de la partie
    int positionClock=0;
    int choix=0;


// La boucle while permet ici de faire tourner le jeu à l'infini pour ne pas terminer le programme tant que la partie n'est pas terminée
    while (turn != 9999)
    {
        for (int i = 0 ; i<nb_joueur ; i++)
        {
            ///reinitialisation des donnees
            next=0;
            positionClock=100;
            t1=clock();
            choix=0;


            ///déclaration et création des bitmaps d'affichage de plateau et de classe
            BITMAP* buffer4;
            buffer4 = create_bitmap(SCREEN_W, SCREEN_H);BITMAP* arena;
            arena = load_bitmap("arena.bmp",NULL);
            BITMAP* fleche;
            fleche = load_bitmap("doigt modif bmp2.bmp",NULL);

            ///affichage de la classe
            affichageClasse(tab,arena,nb_joueur,i,j);

            while((next!=1))
            {
                ///calcul temps du tour
                t2=clock();
                duree=t2-t1;
                if(duree%1000 == 0)
                    positionClock = positionClock+15;

                ///routine d'affichage
                blit(arena, buffer4, 0, 0, 0, 0,SCREEN_W, SCREEN_H);
                show_mouse(buffer4);
                blit(buffer4, screen, 0, 0, 0, 0,SCREEN_W, SCREEN_H);
                clear_bitmap(buffer4);


                ///affichage du temps
                textprintf_ex(arena, font, 378, 57, makecol(0,0,0), -1, "%s",tab[i].pseudo);
                textprintf_ex(arena, font, 630, 100, makecol(0,0,0), -1, "Temps:");
                textprintf_ex(arena, font, 680, positionClock, makecol(0,0,0), -1, "%d",duree/1000);

                ///affichage des donnes joueurs
                textprintf_ex(arena, font, 656, 358, makecol(0,0,0), -1, "%d",tab[i].PV);
                textprintf_ex(arena, font, 656, 373, makecol(0,0,0), -1, "%d",tab[i].PA);
                textprintf_ex(arena, font, 656, 388, makecol(0,0,0), -1, "%d",tab[i].PM);
                textprintf_ex(arena, font, 656, 403, makecol(0,0,0), -1, "%d",tab[i].PU);

                ///affichage de la fleche / joueur2
                affichageFleche(fleche,arena,nb_joueur,tab,compteurTour);
                affichageJoueur2(tab,nb_joueur,arena,buffer4);

                ///Corps à corps
                if(((mouse_b&1)&&(mouse_y>=518)&&(mouse_y<=563)&&(mouse_x>=200)&&(mouse_x<=245)) || choix==1)
                {
                    tab[i].action = 1;
                    choix=1;
                    CorpsACorps(tab,i,nb_joueur,arena);
                    if(tab[i].action==0)
                    {
                        choix=0;
                        next=1;
                    }
                }

                ///Sort 1
                if(((mouse_b&1)&&(mouse_y>=518)&&(mouse_y<=563)&&(mouse_x>=250)&&(mouse_x<=295)) || choix==2)
                {
                    tab[i].action = 2;
                    choix=2;
                    PremierSort(tab,i,nb_joueur,arena);
                    if(tab[i].action==0)
                    {
                        choix=0;
                        next=1;
                    }
                }

                ///Sort 2
                if(((mouse_b&1)&&(mouse_y>=518)&&(mouse_y<=563)&&(mouse_x>=300)&&(mouse_x<=345)) || choix==3)
                {
                    tab[i].action=3;
                    choix=3;
                    DeuxiemeSort(tab,i,nb_joueur,arena);
                    if(tab[i].action==0)
                    {
                        choix=0;
                        next=1;
                    }
                }

                ///Passif
                if((mouse_b&1)&&(mouse_y>=518)&&(mouse_y<=563)&&(mouse_x>=351)&&(mouse_x<=396))
                {
                    tab[i].action=4;
                    choix=4;
                }

                ///Mouvement
                if((mouse_b&1)&&(mouse_y>=518)&&(mouse_y<=563)&&(mouse_x>=402)&&(mouse_x<=447))
                {
                    tab[i].action=5;
                    choix=5;
                    if (compteurTour == nb_joueur-1)
                    {
                        compteurTour = 0;
                    }
                    else
                    {
                    compteurTour++;
                    }
                    next=1;
                }

                ///Ulti
                if((mouse_b&1)&&(mouse_y>=518)&&(mouse_y<=563)&&(mouse_x>=453)&&(mouse_x<=498))
                {
                    tab[i].action=6;
                    choix=6;
                }

                ///Info/help
                if((mouse_b&1)&&(mouse_y>=518)&&(mouse_y<=563)&&(mouse_x>=504)&&(mouse_x<=549))
                {
                    tab[i].action=7;
                    choix=7;
                    Informations(tab,i,arena);
                }

                ///Joueur suivant
                if((mouse_b&1)&&(mouse_y>=518)&&(mouse_y<=563)&&(mouse_x>=555)&&(mouse_x<=600))
                {
                    tab[i].action=8;
                    choix=8;
                    next=1;
                    if (compteurTour == nb_joueur-1)
                    {
                        compteurTour = 0;
                    }
                    else
                    {
                    compteurTour++;
                    }
                }

                ///Duree de jeu
                if(duree>10000)
                {
                    next=1;
                    if (compteurTour == nb_joueur-1)
                    {
                        compteurTour = 0;
                    }
                    else
                    {
                    compteurTour++;
                    }
                }
            }
            if (tab[i].action == 5)
                {
                    move(tab,i,arena,buffer4,nb_joueur);
                    tab[i].action=0;
                }
            turn++;
            if(tab[i].PM<=4)
               tab[i].PM=tab[i].PM+1;
            tab[i].PA=tab[i].PA+2;
            sleep(1);
        }
    }
}

/// LANCEMENT DE LA PARTIE ///

void LancementPartie()
{
    int nb_joueur = 0;
    t_joueur* tab = NULL;
    tab = my_init(tab, &nb_joueur);
    dataFill(tab, &nb_joueur);
    //AffichageEcran3();
    song();
    gestionTours(tab, nb_joueur);
    free(tab);

}

int main()
{
    srand(time(NULL));
    initialisationAllegro();
    LancementPartie();
    allegro_message("Sortie finale");

    allegro_exit();
    return 0;
}END_OF_MAIN();
